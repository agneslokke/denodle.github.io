<!DOCTYPE html>
<html lang="en">
<head>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Sansita:ital,wght@1,700&display=swap" rel="stylesheet">
<title>WØRTLE</title>
<style>
  body {
    font-family: Trebuchet MS, Helvetica, Arial, sans-serif;
    text-align: center;
    background-color: #01222e;
    color: white;
    margin:0 auto;
  }

  .dimmed {
    opacity: 0.5;
    pointer-events: none; /* Disables interaction with dimmed elements */
}
  .board {
    display: grid;
    grid-template-rows: repeat(6, 1fr);
    gap: 5px;
    margin: 20px;
    transition: opacity 0.4s ease-in-out;
  }
  .row {
  display: grid;
  /* ✅ FIX: Columns are now explicitly sized to fit the 60px tiles. */
  grid-template-columns: repeat(5, 60px);
  gap: 10px; /* You can still adjust this value if you want */
  
  /* ✅ ADD: This centers the entire group of 5 tiles within the row. */
  justify-content: center;
}
  .tile {
    box-shadow: 2px 2px 2px #732b2b;
    width: 60px;
    height: 60px;
    border: 3px solid #041c47;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2em;
    font-weight: bold;
    text-transform: uppercase;
    background-color: #121213;
    color: white;
    border-radius:5px;
    transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
  }
  .correct { background-color: #538d4e !important; }
  .present { background-color: #b59f3b !important; }
  .absent { background-color: #3a3a3c !important; }
  .keyboard {
    display: flex;
    flex-direction: column;
    gap: 5px;
    max-width: 600px;
    margin-top:20px;
    margin-bottom:20px;
  }
  .key-row {
    display: flex;
    justify-content: center;
    gap: 5px;
  }
  .key {
    padding: 10px;
    background-color: #818384;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    font-weight: bold;
    color: white;
    user-select: none;
  }
  #hintBtn1, #hintBtn2, #hintBtn3, #hintBtn4 {
    height: 68px;
    background: transparent;
    text-align: left;
    border: 0px;
    border-radius:5px;
    margin-bottom: 5px;
    cursor: pointer;
    padding: 0 0 0 10px;
    color: #214a5a;
    font-size: 10pt;
    align-items: center;
    justify-content: center;
    transition: color 0.3s ease;
  border-bottom: 2px solid #81a4c7;
  }
#hintTitle {
  width:200px;
  text-align: center; 
  text-transform: lowercase;
  margin:0 auto;
  font-weight: 700; 
  font-style:italic;
  font-family: 'Sansita', cursive;
  margin-bottom: 10px; 
  font-size: 1.3em; 
  letter-spacing: 2pt;
  position: relative; 
}
#hintTitle::before {
  content: ""; /* Required for pseudo-elements */
  position: absolute;
  background-color: #4f1868; /* Your desired "offset" color */
  width: 148px; /* Or specific width/height */
  height: 9px; /* Or specific width/height */
  top: 18px; /* Offset from the top */
  left: 25px; /* Offset from the left */
  z-index: -1; /* Place it behind the parent content */
}
#hintTitle:hover::before {
  background-color: #1e0729; /* Your desired "offset" color */
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
}
.hint-button {
  display: none;
}
#hintButtons button {
  width: 180px;
  align-items: flex-start;
  flex-direction: column;
  gap: 4px;
  padding: 5px 0;
  letter-spacing: 1pt;
  font-weight: bold;
  background: rgb(3, 39, 93);
  border: 2px solid rgb(14, 12, 43);
  border-left: 4px solid rgb(14, 12, 43);
  box-shadow: 0 0.2rem rgb(14, 12, 43);
  border-radius: 10px;
  margin: 4px 2px;
  cursor: pointer;
  color: #c7d1d5;
  font-size: 10pt;
  white-space: normal;
  overflow: hidden;
  height: auto;
  transition: background-color 0.3s ease;
}

  #hintButtons button.expanded {
  opacity: 1;
  max-height: 220px;
  }
  #hintButtons button:disabled {
  cursor: default;
  opacity: 1;
}
.hint-label {
    text-transform: lowercase;
    padding-bottom: 2px;
    font-size: 11pt;
    width: 100%;
    letter-spacing: 1pt;
    margin: 0;
    font-family: 'Sansita', cursive;
}
  
  .hint-label.hidden {
      margin-right: 10px;
  }

.hint-text {
  display: block;
  font-weight: normal;
  opacity: 0;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1), 
              opacity 0.5s ease, 
              overflow 0s linear 0.5s;
  width: 100%;
  box-sizing: border-box;
}

.hint-text.visible {
  opacity: 1;
  padding: 7px 15px 7px 7px;
  width: 435px;
  text-transform: uppercase;
  overflow: auto;
  max-height: 68px;
  font-size: 11pt;
  text-align:right;
  font-family: Trebuchet MS, Helvetica, Arial, sans-serif;
}
#hintBtn1:hover, #hintBtn2:hover, #hintBtn3:hover, #hintBtn4:hover,
#hintBtn1.clicked-hint, #hintBtn2.clicked-hint, #hintBtn3.clicked-hint, #hintBtn4.clicked-hint {
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
  background-color: #b3c4e0;
  border-bottom: 2px solid #81a4c7;
}
.styled-button {
    background-color: transparent;
    border: none;
    width: auto;
    color: rgb(255, 255, 255);
    text-shadow: 2px 2px #000000;
    font-size: 10pt;
    font-family: Trebuchet MS, Helvetica, Arial, sans-serif;
    cursor: pointer;
    margin: 0;
    letter-spacing: 1px;
}
  #modalCopyBtn, #showStatsBtn, #showScoreboardBtn, #copy-url-btn, #start-playing-btn {
    background-color: #e4e4e4;
    border: none;
    padding: 10px;
    font-weight: bold;
    font-size: 10pt;
    width: 10em;
    border-radius: 1rem;
    color: rgb(35, 35, 35);
    box-shadow: 0 0.4rem #1d1d1d;
    border: 2px solid #1d1d1d;
    cursor: pointer;
    margin: 5px auto;
    z-index: 100;
  }
  #modalCopyBtn:hover, #showStatsBtn:hover, #showScoreboardBtn:hover, #copy-url-btn:hover, #start-playing-btn:hover {
    background-color: #e97251;
    color: #e9e9e9;
    transition: background-color 0.1s ease-in-out, color 0.1s ease-in-out;
  }
  #modal-stats-display {
    text-align: center;
  }
  h1 { 
    letter-spacing: 1pt; 
    border-bottom:1px solid rgb(34, 65, 78);
    padding:1.4rem;
    margin:0;
    background-color:rgb(3, 22, 27);
    font-family: monospace;
    position: relative;
    text-align: center;
    box-sizing: border-box;
  }
h1 p {
  margin: 0;
  }

.h1-button-group {
  position: absolute;
  top: 50%;
  right: 30px;
  border-radius: 5px;
  transform: translateY(-50%); /* Vertically center the buttons */
}
/* Styling for the simple share modal */
.share-popup {
  /* Use the classic centering method for this modal */
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 1001;
  width: 360px;
  
  /* Hiding and transition */
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}

/* Rule to show the share modal */
.share-popup.show {
  opacity: 1;
  visibility: visible;
}
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6);
  z-index: 1000;

  /* Flexbox properties for centering */
  display: flex;
  align-items: center;     /* Vertical centering */
  justify-content: center; /* Horizontal centering */
  
  /* Hiding and transition */
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}
.modal {
  position: relative;
  width: 360px;
  
  /* The animation for the modal itself */
  transform: scale(0.95);
  opacity: 0;
  transition: opacity 0.3s ease, transform 0.3s ease;
  transition-delay: 0.1s; /* Small delay to let the overlay fade in first */
}



/* This class now controls the visibility of the overlay and the modal inside it */
.modal-overlay.show {
  opacity: 1;
  visibility: visible;
}
/* When the overlay is shown, also animate the modal */
.modal-overlay.show .modal {
  transform: scale(1);
  opacity: 1;
}
  #modal-message { font-size: 16pt; width:auto; font-family:monospace; }
  .modal-content {
  position: relative; 
  width:300px;
  max-height:80%;
  background-color: #e1dbd9;
  border-top:20px solid rgb(206, 86, 17);
  border-radius:10px;
  padding: 15px 30px 30px 30px;
  text-align: center;
  display: flex;
  flex-direction: column;
  gap: 0px;
  color: rgb(33, 33, 33);
  max-height: 85vh;      /* Set a max height relative to the screen */
  overflow-y: auto;      /* Add a vertical scrollbar ONLY when needed */
  }
  #modal-summary {
    white-space: pre-wrap;
    font-family: monospace;
    font-size: 1.2em;
    color: rgb(33, 33, 33);
    letter-spacing: 2pt;
  }
  #hintButtonsContainer {
    display: flex;
    flex-direction: column;
    justify-content: center;
    gap: 3px;
    margin-top: 30px;
  }
  #secretWordColor {
  color: #cd1616; /* Example: a bright orange color */
}
.word-host-input {
  background: #021a24;
  font-size:11pt;
  color: #c7d1d5;
  border: none;
  padding: 7px;
  border-radius: 6px;
  min-width: 197px;
  margin-top: 5px;
  margin-bottom: 5px;
  margin-left: 30px;
  text-align: center;
  transition: background 0.2s ease; /* Smooth color change */
}
.host-input {
  background: #021a24;
  font-size:11pt;
  color: #c7d1d5;
  border: none;
  padding: 8px;
  border-radius: 6px;
  width: 200px;
  display: block;
  margin: auto;
  margin-top: 5px;
  margin-bottom: 5px;
  text-align: center;
  transition: background 0.2s ease; /* Smooth color change */
}

.host-input::placeholder, .word-host-input::placeholder, #funFactInput::placeholder {
  color: #6f8a94;
}
.host-input:not(:placeholder-shown), .word-host-input:not(:placeholder-shown), #funFactInput:not(:placeholder-shown) {
  background: #010f15;
}
#hintInput4Container {
  margin: auto;
  margin-top: 5px;
  margin-bottom: 5px;
  display: block;
  background: #021a24;
  padding: 8px;
  width: 200px;
  border-radius: 6px;
  text-align:center;
  transition: background 0.2s ease; /* Smooth color change */
}

#hintInput4Container.darkened {
  background: #010f15;
}
#secretInput {
  text-transform: uppercase;
}

#modal-stats-container {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.5s ease-in-out, margin-top 0.5s ease-in-out;
    background-color: #d8d8d8;
    color: #333;
    padding: 0 10px;
    border-radius: 8px;
  }

  #modal-stats-container.expanded {
    max-height: 500px;
  }

  .stats-line {
    margin: 5px 0;
    font-family: monospace;
  }

  .button-group {
    display: inline-block;
    flex-direction: column;
    gap: 15px;
    width: 100%;
    align-items: center;
  }
  
  .key:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  /* Add the class to apply the animation */
  .shake {
    animation: shake 0.5s ease-in-out;
  }
  #funFactInput {
  background: #021a24;
  color: #c7d1d5;
  border: none;
  padding: 8px 28px;
  min-height: 70px;
  font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
  border-radius: 6px;
  font-size: 11pt;
  width: 300px;
  display: block;
  margin: auto;
  margin-top: 5px;
  margin-bottom: 5px;
  text-align: center;
  transition: background 0.2s ease;
  resize: vertical; /* Let users adjust height if they want */
  line-height: 1.4;
  }
  .fun-fact-section {
    background-color: #d8d8d8; /* A dark blue-gray background */
    color: #333; /* A light off-white font color */
    font-size: 11pt; /* Slightly larger font size */
    box-shadow: 0 0.4rem #5d849f;
    border:2px solid #5d849f;
    padding: 10px;
    border-radius: 8px;
    margin-top: 10px;
    min-height:60px;
    max-height:120px;
    overflow:scroll;
  }
  .fun-fact-section h2 {
    font-size:12pt;
    margin:4px 0 6px 0;
  }
  .fun-fact-section::-webkit-scrollbar {
  width: 10px; /* Width of the vertical scrollbar */
}
/* Scrollbar thumb */
.fun-fact-section::-webkit-scrollbar-thumb {
  background-color: #a14612; /* Color of the thumb */
  border-radius: 0px 6px; /* Rounded corners for the thumb */
}
/* Track */
.fun-fact-section::-webkit-scrollbar-corner {
  background: #4e1919;
  border-radius: 6px 0px;
}
.help-button {
  background: #07548a;
  color: white;
  border: none;
  border-radius: 50%;
  width: 29px;
  height: 29px;
  font-weight: bold;
  font-size: 18px;
  line-height: 1;
  cursor: pointer;
  vertical-align: middle;
  user-select: none;
  transition: background-color 0.3s ease;
}

.help-button:hover {
  background-color: #0a73c2;
}
.help-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #e1dbd9;
  color: #212121;
  max-width: 380px;
  border-radius: 10px;
  box-shadow: 0 0 15px rgba(0,0,0,0.5);
  z-index: 9999;
  display: flex; /* Use flex by default */
  flex-direction: column;
  outline: 2px solid orange;
  padding: 2px 6px;
}/* Hide when hidden attribute is present */
.help-popup[hidden] {
  display: none;
}
.help-popup:focus {
  outline: 2px solid orange;
}
.help-popup-content {
  position: relative;
  padding: 20px 45px;
    overflow: scroll;
    max-height: 550px;
    font-size: 11.5pt;
}
.close-btn {
  position: absolute;
  top: -8px;
  right: 0px;
  width: 25px;
  height: 25px;
  border: none;
  background: transparent;
  z-index: 1000;
  border-radius: 50%;
  font-size: 17pt;
  cursor: pointer;
  color: #5e2603;
  font-family: 'Sansita', cursive;
}
.close-btn:hover {
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
  color: #000;
}
.close-help-btn, .close-hint-btn {
    position: absolute;
    top: 0px;
    right: 1px;
    width: 30px;
    height: 30px;
    border: none;
    background: transparent;
    z-index: 1000;
    border-radius: 50%;
    font-size: 19pt;
    cursor: pointer;
    color: #707070;
    font-family: 'Sansita', cursive;
}
.close-help-btn:hover, .close-hint-btn:hover {
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
  color: #000;
}
.close-hint-btn {
  top:-3px;
}
.help-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.4); /* dim background */
  z-index: 9998; /* just below the popup */
}
/* The dark background overlay */
#hintPopupOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* This z-index is crucial. It must be high. */
  z-index: 999;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0s 0.3s;
}

/* The popup box itself */
.hint-popup {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  max-width: 400px;
  margin: 0 auto;
  padding: 10px;
  background-color: #d0d9dc;
  border-radius: 10px;
  border: 2px solid #b3c4e0;
  /* This must have a HIGHER z-index than the overlay. */
  z-index: 1000;
  transform: translateY(100%);
  opacity: 0;
  visibility: hidden;
  transition: transform 0.3s ease, opacity 0.3s ease, visibility 0s 0.3s;
}

/* --- The rest of the CSS remains the same --- */

/* Active (visible) state for the popup */
.hint-popup.show {
  transform: translateY(0);
  opacity: 1;
  visibility: visible;
  transition-delay: 0s;
}

/* When the popup is shown, also show the overlay */
.hint-popup.show ~ #hintPopupOverlay {
  opacity: 1;
  visibility: visible;
  transition-delay: 0s;
}
#share-message-box {
    width: 100%;
    height: 80px;
    padding: 10px;
    box-sizing: border-box;
    background-color: #d8d8d8;
    border: 2px dashed #ccc;
    border-radius: 15px;
    color: #4b819d;
    font-family: 'Trebuchet MS', Helvetica, Arial, sans-serif;
    font-size: 1em;
    resize: none;
}
#share-message-box:focus {
    outline: none;
}
/* Container for the custom tooltip */
.custom-tooltip {
  position: relative; /* This is required for positioning the tooltip */
  cursor: pointer;
}
/* The tooltip itself, created with a pseudo-element */
.custom-tooltip::after {
  content: attr(data-tooltip); /* Grabs the text from the data-tooltip attribute */
  position: absolute;
  top: 100%; /* Position it above the button */
  left: 50%;
  transform: translateX(-50%);
  margin-top: 10px; /* Space between button and tooltip */
  /* Appearance */
  background-color: #d8d8d8;
  color: #4b819d;
  font-weight:400;
  padding: 8px;
  border-radius: 4px;
  font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
  font-size: 14px;
  white-space: nowrap; /* Prevent the text from wrapping */
  /* Visibility and instant transition */
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.1s ease, visibility 0.1s ease;
  transition-delay: 0s; /* No delay on hiding */
}

/* Show the tooltip on hover */
.custom-tooltip:hover::after {
  opacity: 1;
  visibility: visible;
  transition-delay: 0s; /* No delay on showing */
}

table {
  font-family: monospace;
  font-size:10pt;
  border-collapse: collapse;
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
}
tr>:nth-child(2){
  min-width: 35px;
}
tr>:nth-child(1), tr>:nth-child(4) {
  max-width:20px;
  text-align:center;
}
tr>:nth-child(3) {
  max-width:30px;
  text-align:center;
}
tr {
  text-transform: uppercase;
}
td, th {
  border: 1px #ddd;
  border-style: none solid solid none;
  padding: 5px;
  text-align:left;
}
td {
  max-width: 10px;
  overflow: scroll;
}
th {
  border:0px;
  text-transform: capitalize;
}
tr:first-child td:first-child { border-top-left-radius: 10px; }
tr:first-child td:last-child { border-top-right-radius: 10px; }

tr:last-child td:first-child { border-bottom-left-radius: 10px; }
tr:last-child td:last-child { border-bottom-right-radius: 10px; }

tr:first-child td { border-top-style: solid; }
tr td:first-child { border-left-style: solid; }
tr:nth-child(even){
  background-color: #01222e;
}
#game-over-modal {
  position: relative; /* Establishes a stacking context */ /* Acts as the positioning anchor */
}
.side-panel {
  position: absolute;
  top: 35px;
  left: 360px;
  z-index: 1;
  /* --- MODIFIED --- */
  width: 0;
  overflow: hidden; /* This now hides the static inner content */
  transition: width 0.4s ease-in-out;
  padding: 0; /* Padding is now on the inner wrapper */
  /* Your other styles */
  height: 90%;
  background-color: #021a24;
  color: #fff;
  border-radius: 0 12px 12px 0;
  box-shadow: 5px 0 15px rgba(0, 0, 0, 0.2);
  pointer-events: none;
}
.side-panel.show {
  width: 280px; /* The outer container still expands to this width */
  pointer-events: auto;
}
/* --- ADD THIS NEW RULE --- */
.side-panel-content {
  /* This container has a fixed width, so the text inside doesn't reflow */
  width: 280px;
  padding: 20px;
  height: 100%;
  overflow: auto; /* Adds a scrollbar if content is too tall */
  box-sizing: border-box; /* Keeps padding inside the defined width/height */
}
    /* Add these new styles for the scoreboard summary */
    #scoreboard-summary-container {
        padding: 10px 15px;
        border-bottom: 1px solid #444; /* A separator line */
        margin-bottom: 10px;
    }

    .summary-stat {
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 14px;
    }

    .summary-stat:last-child {
        margin-bottom: 0;
    }

    .stat-label {
        width: 90px; /* Helps align the labels */
        text-align: center;
        color: #c7d1d5;
        flex-shrink: 0;
    }

    .stat-bar-container {
        flex-grow: 1;
        height: 20px;
        border-right: 3px dotted #384d58;
        overflow: hidden;
    }

    .stat-bar {
        height: 100%;
        background-color: rgb(92, 17, 17); /* A color that fits your theme */
        border-radius: 5px;
        transition: width 0.5s ease-in-out;
        text-align: center;
    text-shadow: 1px 2px #000000;
    color: #e5e8ea;
        font-weight: bold;
        line-height: 20px; /* Vertically center text */
        white-space: nowrap;
    }
.modal-button-container {
  display: flex;
  flex-direction: column; /* Stacks items vertically */
  align-items: center;   /* Centers the buttons horizontally */
  gap: 0px;             /* Adds some space between each button */
  width: 100%;           /* Ensures the container takes up the available space */
}

/* Add this CSS to your stylesheet */

#word-status-indicator {
    font-size: 8pt;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    font-family: sans-serif;
    height: 20px;
    margin-left: 10px;
    box-sizing: border-box;
}

#word-status-indicator.valid {
    color: #10d63d;
    border-radius: 15px;
    border: 2px solid #05a400;
    background-color: #116517;
}

#word-status-indicator.invalid {
    color: #ff4127;
    border-radius: 15px;
    border: 2px solid #db1c02;
    background-color: #8d1d1d;
}

/* Simple loading spinner */
#word-status-indicator.loading::after {
  content: '';
  display: block;
  width: 15px;
  height: 15px;
  border: 3px solid #7f8c8d;
  border-top-color: #ecf0f1;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Shake animation for the input field on error */
.shake {
  animation: shake 0.5s;
}

@keyframes shake {
  10%, 90% { transform: translateX(-1px); }
  20%, 80% { transform: translateX(2px); }
  30%, 50%, 70% { transform: translateX(-4px); }
  40%, 60% { transform: translateX(4px); }
}
/* Add this new CSS rule */
.input-with-indicator {
  display: flex;
  justify-content: center;
  align-items: center;
}

/* --- Account Sidebar Styles --- */
#account-sidebar {
    font-family: monospace;
    position: fixed;
    top: 0;
    right: -320px; /* Start off-screen */
    width: 300px;
    height: 100%;
    background-color: #01222e;
    border-left: 2px solid rgb(34, 65, 78);
    box-shadow: -5px 0 15px rgba(0,0,0,0.4);
    z-index: 9999;
    padding: 10px;
    transition: right 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    color: #c7d1d5;
    overflow-y: auto;
}

#account-sidebar.show {
    right: 0; /* Slide into view */
}

#account-sidebar h2 {
    text-align: center;
    margin-top: 25px;
    text-transform: lowercase;
    font-family: 'Sansita', cursive;
    position: relative; /* Establishes a positioning context for the ::before element */
    display: inline-block; /* Makes the h2 only as wide as the text inside it */
}

#account-sidebar h2::before {
    content: "";
    position: absolute;
    background-color: #4f1868;
    height: 9px;
    width: 110%; /* Makes the element as wide as the text */
    left: -5%;     /* Aligns it to the start of the text */
    bottom: -2px; 
    z-index: -1;
}

.account-section {
    margin-top: 20px;
    margin-bottom: 20px;
}
.user-games-title {
    font-weight: 400;
    text-transform: lowercase;
}
.games-list {
    display: flex;
    flex-direction: column;
    gap: 0px;
    border-radius: 8px;
    padding: 10px;
    min-height: 30px;
}

.games-list a {
    color: #81a4c7;
    text-decoration: none;
    background-color: transparent;
    padding: 8px;
    border-radius: 5px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background-color 0.2s ease;
}

.game-status {
    font-size: 0.8em;
    font-style: italic;
    color: #c7d1d5;
    opacity: 0.8;
}

.game-list-item {
    background-color: transparent;
    padding: 2px;
    border-radius: 5px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background-color 0.2s ease;
}

.game-list-item:hover {
    background-color: #060e12;
}

.game-list-item a {
    color: #edf6ff;
    text-decoration: none;
    letter-spacing: 1px;
    font-size:9pt;
}

.game-item-actions {
    display: flex;
    gap: 0px;
}

.game-item-actions button {
    background: transparent;
    border: none;
    color: #c7d1d5;
    border-radius: 50%;
    cursor: pointer;
    width: 28px;
    height: 28px;
    font-size: 12pt;
    margin-top:2px;
    transition: background-color 0.2s ease, color 0.2s ease;
}

.game-item-actions button svg {
    color: #1898cb;
}
.game-item-actions button:hover svg {
    transition: background-color 0.2s ease, color 0.2s ease;
    stroke: #E57373; /* A nice red color for the hover state */
}
.game-item-actions button:hover {
    color: #fff;
}
#account-stats-section {
    display: flex;
    justify-content: space-around;
    text-align: center;
    padding: 15px 10px;
    /* background-color: #021a24; */
    border-radius: 8px;
    margin-bottom: 20px;
}

.stat-item {
    display: flex;
    flex-direction: column;
}

.stat-value {
    font-size: 1.4em;
    font-weight: bold;
    color: #fff;
}

.stat-label {
    font-size: 0.8em;
    color: #81a4c7;
    text-transform: uppercase;
}
.login-prompt-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 5px; /* A smaller gap suitable for these elements */
    width: 100%; /* Ensures it takes up space to center its contents */
}
/* --- New Sidebar Loader and Content Styles --- */
#sidebar-loader {
    display: none; /* Hidden until we need it */
    text-align: center;
    margin-top: 50px;
    font-size: 1.1em;
    color: #81a4c7;
}

/* A simple CSS spinner animation */
.spinner {
    margin: 0 auto 15px auto;
    border: 4px solid rgba(255, 255, 255, 0.2);
    border-left-color: #fff;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
}

#sidebar-content {
    visibility: hidden; /* Hide the content until it's loaded */
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
}

#sidebar-content.loaded {
    visibility: visible;
    opacity: 1;
}
/* --- Toast Notification Styles --- */
#toast-container {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  pointer-events: none; /* Allows clicks to go "through" the container */
}

.toast {
  background-color: #f0f0f0;
  color: #333;
  padding: 12px 20px;
  border-radius: 25px;
  font-family: 'Trebuchet MS', Helvetica, Arial, sans-serif;
  font-size: 1em;
  font-weight: bold;
  box-shadow: 0 4px 10px rgba(0,0,0,0.2);
  animation: fadeInOut 3s ease-in-out forwards;
  pointer-events: all; /* Toasts themselves can be interacted with if needed */
}

/* A special style for error messages */
.toast.error {
  background-color: #c53a3a;
  color: white;
}

@keyframes fadeInOut {
  0% {
    opacity: 0;
    transform: translateY(-20px);
  }
  10%, 90% {
    opacity: 1;
    transform: translateY(0);
  }
  100% {
    opacity: 0;
    transform: translateY(20px);
  }
}
/* --- FINAL UNIFIED LAYOUT & HEADER STYLES --- */

/* 1. This styles the OUTER, full-width header bars */
#header-setup {
  display: none;
  background-color: #041c27;
  padding: 5px 10px;
  border-bottom: 1px solid #06090a;
  justify-content: center;
  height:32px;
}

/* 2. This is the INNER wrapper that constrains the header content */
.header-content-wrapper {
  width: 100%;
  max-width: 500px; /* Adjust this value to match your game board if needed */
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
}

/* 3. This creates the main centered column for your setup form and game */
#setup,
#game {
  max-width: 500px;
  width: 100%;
  margin-left: auto;
  margin-right: auto;
  box-sizing: border-box; 
  transition: opacity 0.4s ease-in-out;
  display: none;
}

/* 4. This styles the individual sections INSIDE the wrapper (username, host, etc.) */
.header-content-wrapper > div {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
}

/* 5. This unifies the font and padding for text and buttons inside the header */
.header-content-wrapper p,
.header-content-wrapper button {
  font-family: 'Trebuchet MS', Helvetica, Arial, sans-serif;
  font-size: 10pt;
  letter-spacing: 1px;
  text-shadow: 2px 2px #000000;
  margin: 0;
  padding: 4px;
}
#setup-form-content {
  transition: opacity 0.4s ease-in-out;
}
#host-credit {
  font-size:9pt;
  color: #818384;
  margin-top: 25px;
  letter-spacing: 1px;
  font-family:monospace;
}

</style>
</head>
<body>
<div id="toast-container"></div>
<div id="mainContent">
<h1>
  <p><span style="color:rgb(243, 202, 186);">Cross-Germanic</span> WØRTLE</p>
  <div class="h1-button-group">
    <button id="newGameBtn" aria-label="Create New Game" class="help-button custom-tooltip" data-tooltip="New Wørtle">+</button>
    <button id="helpBtn" aria-label="Show Help" data-tooltip="Info" class="help-button custom-tooltip">?</button>
    <button id="accountBtn" aria-label="My Account" class="help-button custom-tooltip" data-tooltip="My Account">U</button>
  </div>
</h1>
  <div id="loader" style="margin-top: 100px; font-size: 1.2em;">Loading Wørtle...</div>

<div id="header-setup">
    <div class="header-content-wrapper">
      <div id="setup-username-area" class="user-info-area"></div>
    </div>
</div>

<div id="setup" style="padding-bottom:10px;">
  <div id="setup-form-content">
  <p style="margin-bottom:20px;">Enter a secret word and optional hints for the user to reveal</p>
    
  <div class="input-with-indicator">
    <input type="text" id="secretInput" maxlength="5" placeholder="Secret word" style="border:2px solid rgb(92, 17, 17);" class="word-host-input"/>
    <span id="word-status-indicator"></span>
  </div>
  
    <button id="generateWordBtn" style="margin:5px 0 7px 0;">Pick Random Word</button>
    <input type="text" id="hintInput" placeholder="Language" class="host-input"/>
  <input type="text" id="hintInput2" placeholder="Part of speech" class="host-input"/>
  <input type="text" id="hintInput3" placeholder="Context clue" class="host-input"/>
<div id="hintInput4Container">
  <p style="margin:0 0 5px 0; font-size:11pt; color:#c7d1d5;">Special character(s)</p>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Ä" class="specialCharCheckbox"> Ä
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Ö" class="specialCharCheckbox"> Ö
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Ü" class="specialCharCheckbox"> Ü
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="ẞ" class="specialCharCheckbox"> ẞ
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Æ" class="specialCharCheckbox"> Æ
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Ø" class="specialCharCheckbox"> Ø
  </label>
  <label style="display:block; margin-bottom:4px; cursor:pointer;">
    <input type="checkbox" value="Å" class="specialCharCheckbox"> Å
  </label>
</div>
  <textarea id="funFactInput" placeholder="Fun fact about the word (to be shown after the game is over)"></textarea>
  <button onclick="startGame()" style="margin:10px;">Create Game</button>
</div>
</div>

  
  <p id="message"></p>

<div id="game">
  <div id="board" class="board"></div>

<div id="hintButtons" style="display: none;">
  <div id="hintTitle" style="cursor:pointer;">Need a hint?</div>
</div>

  <div id="keyboard" class="keyboard"></div>
  <p id="host-credit"></p>
</div>

<div id="game-over-overlay" class="modal-overlay">

  <div id="game-over-modal" class="modal">

    <div id="scoreboard-panel" class="side-panel">
      <div class="side-panel-content">
        <h2 style="font-size:14pt;">Scoreboard for <span id="scoreboard-word"></span></h2>
        <div id="scoreboard-summary-container"></div>
        <div id="scoreboard-container"></div>
      </div>
    </div>

      <button id="closeModalBtn" class="close-btn">&times;</button>
    <div class="modal-content">
      <p id="modal-message"></p>
      <pre id="modal-summary"></pre>

      <div class="modal-button-container">
        <button id="modalCopyBtn">Copy Result</button>
        <button id="showStatsBtn">Show My Stats</button>
        <div id="modal-stats-container"></div>
        <button id="showScoreboardBtn">View Scoreboard</button>
      </div>
    </div>

  </div>
</div>

<div id="share-modal" class="share-popup">
  <div class="modal-content">
    <p style="font-weight:600;margin-bottom:5px;font-size: 12pt;width:auto;font-family:monospace;">Share with others:</p>
    <textarea id="share-message-box" readonly></textarea>
    <div class="button-group">
      <button id="copy-url-btn">Copy Text</button>
      <button id="start-playing-btn">Start Playing</button>
    </div>
  </div>
</div>
</div>

<div id="helpOverlay" class="help-overlay" hidden></div>
<div id="helpPopup" class="help-popup" role="dialog" aria-modal="true" aria-labelledby="helpTitle" tabindex="-1" hidden>
  <div class="help-popup-content">
    <button id="closeHelpBtn" aria-label="Close help" class="close-help-btn">&times;</button>
    <h2 id="helpTitle">How to Wørtle</h2>
    <p>Enter or generate a secret word, as well as any optional hints for the user to reveal. If the word is not accepted, it is either not in the word list or has already been used. Share the URL with players.</p>
    <hr>
    <p>WØRTLE is currently enabled for:<br>
    German &mdash; 3902 words<br>
    Norwegian &mdash; 15651 words<br>
    Swedish &mdash; 4585 words<br>
    Danish &mdash; 1392 words<br>
    English &mdash; 14849 words</p>
    <p>Each language utilises a limited word list, which vary in how extensive they are.</p>
    <hr>
    <p><i>Created by lokke@ and bicks@<br>Original idea by aottl@</i></p>
    <p>Find a bug? Want to add a word to the word list? Or have any other suggestions for improvement?<br>Please write to lokke@google.com</p>
  </div>
</div>

<div id="hintPopup" class="hint-popup" role="dialog" aria-modal="true" aria-labelledby="hintPopupTitle">
    <button id="closeHintPopupBtn" aria-label="Close hint popup" class="close-hint-btn">&times;</button>
    <div id="hintButtonsContainer">
        <button id="hintBtn1" class="hint-button" onclick="showHint(1)">
            <span class="hint-label">Language</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn2" class="hint-button" onclick="showHint(2)">
            <span class="hint-label">Part Of Speech</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn3" class="hint-button" onclick="showHint(3)">
            <span class="hint-label">Context</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn4" class="hint-button" onclick="showHint(4)">
            <span class="hint-label">Special Character(s)</span>
            <span class="hint-text"></span>
        </button>
    </div>
</div>

<div id="account-overlay" class="help-overlay" hidden></div>
<div id="account-sidebar">
  <button id="closeAccountBtn" class="close-help-btn">&times;</button>
  <h2 id="account-sidebar-title">My Account</h2>

  <div id="sidebar-loader">
    <div class="spinner"></div>
    Loading account...
  </div>

  <div id="sidebar-content">
    <div id="account-stats-section" class="account-section"></div>
    <div class="account-section">
        <h3 id="hosted-games-title" class="user-games-title">My Games</h3>
        <div id="hosted-games-list" class="games-list"></div>
    </div>
    <div class="account-section">
        <h3 id="played-games-title" class="user-games-title">Played Games</h3>
        <div id="played-games-list" class="games-list"></div>
    </div>
  </div>
</div>

<div id="hintPopupOverlay" class="popup-overlay"></div>



<script>
let secret = "";
let customHint1 = "";
let customHint2 = "";
let customHint3 = "";
let customHint4 = "";
let customFunFact = "";
let hintUsed1 = false;
let hintUsed2 = false;
let hintUsed3 = false;
let hintUsed4 = false;
let currentRow = 0;
let currentCol = 0;
const rows = 6;
const cols = 5;
let grid = [];
let keyColors = {};
let guessHistory = [];
let colorHistory = [];
let usernameSet = false;
let isAnimating = false;
let gameCreatedDate = null;
let hintExpanded1 = false;
let hintExpanded2 = false;
let hintExpanded3 = false;
let hintExpanded4 = false;
let scoreboardListener = null;
let userListener = { ref: null, listener: null };
const hintTitle = document.getElementById("hintTitle");
const hintPopup = document.getElementById("hintPopup");
const hintPopupOverlay = document.getElementById("hintPopupOverlay");
const closeHintPopupBtn = document.getElementById("closeHintPopupBtn");
const game = document.getElementById("game");
const SUPPORTED_LANGUAGES = ['german', 'norwegian', 'english', 'swedish', 'danish']; // <-- Add all your file names here (without .txt)
const allValidWords = new Set();


// Add this corrected block to the top of your script

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyDGepZP9hu3hHAL1wfrp4gjIurEPLPUbaw",
  authDomain: "woertle-7dc73.firebaseapp.com",
  databaseURL: "https://woertle-7dc73-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "woertle-7dc73",
  storageBucket: "woertle-7dc73.firebasestorage.app",
  messagingSenderId: "97063588719",
  appId: "1:97063588719:web:dc734f9c0772d49e5b0e9a"
};

// Initialize Firebase using the global firebase object
firebase.initializeApp(firebaseConfig);

// Create a database reference for your other functions to use
const database = firebase.database();

(async () => {
  await loadAllWordLists();
  // You can enable the "Create Game" button here after lists are loaded
})();

// --- NEW: Debounce timer for live validation ---
let debounceTimer;

/**
 * Converts a string to uppercase, correctly handling the German Eszett (ß -> ẞ).
 * The standard .toUpperCase() converts 'ß' to 'SS'.
 * @param {string} str The string to convert.
 * @returns {string} The uppercased string.
 */
function germanFriendlyUpperCase(str) {
    return str.replace(/ß/g, 'ẞ').toUpperCase();
}

/**
 * Validates the secret word in the input field.
 * Checks length, dictionary, and database availability.
 * Updates the UI with a status indicator (✅, ❌, or loading spinner).
 * @returns {Promise<boolean>} - True if the word is valid and available, otherwise false.
 */
async function validateSecretWord() {
    const secretInput = document.getElementById('secretInput');
    const indicator = document.getElementById('word-status-indicator');
    const word = germanFriendlyUpperCase(secretInput.value.trim());

    // Clear previous indicator and state
    indicator.innerHTML = '';
    indicator.className = '';

    if (!word) {
        return false;
    }

    if (word.length !== 5 || !/^[A-ZÄÖÜßẞÆØÅ]+$/i.test(word)) {
        indicator.innerHTML = 'X';
        indicator.className = 'invalid';
        return false;
    }

    if (!allValidWords.has(word.toLowerCase())) {
        indicator.innerHTML = 'X';
        indicator.className = 'invalid';
        return false;
    }

    // Show loading spinner while we check the database
    indicator.className = 'loading';

    try {
        const gameRef = database.ref('games/' + word);
        const snapshot = await gameRef.once('value');

        if (snapshot.exists()) {
            // Word is taken
            indicator.innerHTML = 'X';
            indicator.className = 'invalid';
            return false;
        } else {
            // Word is available and valid
            indicator.innerHTML = 'Y';
            indicator.className = 'valid';
            return true;
        }
    } catch (error) {
        console.error("Firebase check failed:", error);
        indicator.innerHTML = '⚠️'; // Network error symbol
        indicator.className = 'invalid';
        return false;
    }
}


// Base64 helpers
function base64Encode(str) { return btoa(unescape(encodeURIComponent(str))); }
function base64Decode(str) { try { return decodeURIComponent(escape(atob(str))); } catch { return null; } }

function getSecretFromURL() {
  const params = new URLSearchParams(window.location.search);
  const encodedWord = params.get("w");
  const encodedHint1 = params.get("h1");
  const encodedHint2 = params.get("h2");
  const encodedHint3 = params.get("h3");
  const encodedHint4 = params.get("h4");

  if (!encodedWord) return null;
  const decodedWord = base64Decode(encodedWord);

  customHint1 = encodedHint1 ? base64Decode(encodedHint1) : "";
  customHint2 = encodedHint2 ? base64Decode(encodedHint2) : "";
  customHint3 = encodedHint3 ? base64Decode(encodedHint3) : "";
  customHint4 = encodedHint4 ? base64Decode(encodedHint4) : "";

  const encodedFunFact = params.get("ff");
  customFunFact = encodedFunFact ? base64Decode(encodedFunFact) : "";

  // ✅ Parse and store creation date ONLY if not already set
  if (!gameCreatedDate) {
    const encodedDate = params.get("d");
    if (encodedDate) {
      const decodedDateStr = base64Decode(encodedDate);
      const parsedDate = new Date(decodedDateStr);
      if (!isNaN(parsedDate)) {
        gameCreatedDate = parsedDate;
      }
    }
  }

  if (decodedWord && /^[A-ZÆØÅÄÖÜẞ]{5}$/.test(decodedWord)) {
    return decodedWord.toUpperCase();
  }
  return null;
}

const hintContainer = document.getElementById("hintInput4Container");
const specialCharBoxes = document.querySelectorAll(".specialCharCheckbox");

function updateHintContainerBackground() {
  const anyChecked = Array.from(specialCharBoxes).some(cb => cb.checked);
  hintContainer.classList.toggle("darkened", anyChecked);
}

specialCharBoxes.forEach(cb => {
  cb.addEventListener("change", updateHintContainerBackground);
});

function saveSetupState() {
  const setupState = {
    secret: document.getElementById('secretInput').value,
    hint1: document.getElementById('hintInput').value,
    hint2: document.getElementById('hintInput2').value,
    hint3: document.getElementById('hintInput3').value,
    funFact: document.getElementById('funFactInput').value,
    // Save an array of the values of all checked boxes
    specialChars: Array.from(document.querySelectorAll('.specialCharCheckbox:checked')).map(cb => cb.value)
  };
  // Convert the object to a string and save it
  localStorage.setItem('wurtleSetupState', JSON.stringify(setupState));
}

function loadSetupState() {
  const savedStateJSON = localStorage.getItem('wurtleSetupState');
  if (savedStateJSON) {
    const savedState = JSON.parse(savedStateJSON);
    
    // Repopulate all the text fields
    document.getElementById('secretInput').value = savedState.secret || '';
    document.getElementById('hintInput').value = savedState.hint1 || '';
    document.getElementById('hintInput2').value = savedState.hint2 || '';
    document.getElementById('hintInput3').value = savedState.hint3 || '';
    document.getElementById('funFactInput').value = savedState.funFact || '';

    // Re-check all the necessary checkboxes
    if (savedState.specialChars && savedState.specialChars.length > 0) {
      document.querySelectorAll('.specialCharCheckbox').forEach(cb => {
        if (savedState.specialChars.includes(cb.value)) {
          cb.checked = true;
        }
      });
    }
  }
}

function generateShareURL(word, hint1, hint2, hint3, hint4, funFact) {
  const url = new URL(window.location);
  url.searchParams.set("w", base64Encode(word));
  if (hint1) url.searchParams.set("h1", base64Encode(hint1));
  if (hint2) url.searchParams.set("h2", base64Encode(hint2));
  if (hint3) url.searchParams.set("h3", base64Encode(hint3));
  if (hint4) url.searchParams.set("h4", base64Encode(hint4));
  if (funFact) url.searchParams.set("ff", base64Encode(funFact));
  const today = new Date().toISOString();
  url.searchParams.set("d", base64Encode(today));
  return url.href;
}

async function updateStats(username, won, guesses) {
    if (!username) return;

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const statsRef = database.ref(`userProfiles/${sanitizedUsername}/stats`);

    try {
        await statsRef.transaction(currentStats => {
            // If the user has no stats yet, initialize them.
            if (currentStats === null) {
                currentStats = { gamesPlayed: 0, wins: 0, totalGuesses: 0 };
            }
            
            // Increment the values
            currentStats.gamesPlayed++;
            if (won) {
                currentStats.wins++;
                currentStats.totalGuesses += guesses;
            }
            
            return currentStats; // Return the new data to be saved.
        });
    } catch (error) {
        console.error("Could not update stats in Firebase:", error);
    }
}

async function displayStats(username) {
    const user = username || "Player";
    const defaultStats = { gamesPlayed: 0, wins: 0, totalGuesses: 0 };
    let stats = { ...defaultStats }; // Use a copy

    if (username) {
        try {
            const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
            const statsRef = database.ref(`userProfiles/${sanitizedUsername}/stats`);
            const snapshot = await statsRef.once('value');
            if (snapshot.exists()) {
                stats = snapshot.val();
            }
        } catch (error) {
            console.error("Could not fetch stats from Firebase:", error);
        }
    }

    // Calculate the derived stats
    const winPct = stats.gamesPlayed > 0 ? ((stats.wins / stats.gamesPlayed) * 100).toFixed(1) : "0.0";
    const avgGuesses = stats.wins > 0 ? (stats.totalGuesses / stats.wins).toFixed(2) : "-";
    
    // Return a proper JavaScript object with key: value pairs
    return {
        username: user,
        gamesPlayed: stats.gamesPlayed,
        wins: stats.wins,
        totalGuesses: stats.totalGuesses,
        winPct: winPct,
        avgGuesses: avgGuesses
    };
}
async function startGame() {
    const hostUsername = localStorage.getItem("gerNordleUsername");
    if (!hostUsername) {
        showToast("You must be logged in to host a game.", "error");
        return;
    }
    
    const isWordAvailable = await validateSecretWord();
    if (!isWordAvailable) {
        const secretInput = document.getElementById('secretInput');
        if (secretInput) {
            secretInput.classList.add('shake');
            setTimeout(() => secretInput.classList.remove('shake'), 500);
        }
        return;
    }

    const setupDiv = document.getElementById("setup");
    const headerSetup = document.getElementById("header-setup");
    const inputWord = germanFriendlyUpperCase(document.getElementById("secretInput").value.trim());
    const inputHint1 = document.getElementById("hintInput").value.trim();
    const inputHint2 = document.getElementById("hintInput2").value.trim();
    const inputHint3 = document.getElementById("hintInput3").value.trim();
    const inputHint4 = Array.from(document.querySelectorAll(".specialCharCheckbox:checked")).map(cb => cb.value).join(", ");
    const inputFunFact = document.getElementById("funFactInput").value.trim();

    secret = inputWord;
    customHint1 = inputHint1;
    customHint2 = inputHint2;
    customHint3 = inputHint3;
    customHint4 = inputHint4;
    customFunFact = inputFunFact;

    const metadataRef = database.ref('games/' + secret + '/metadata');
    try {
        const metadataToSave = {
            word: secret,
            hint1: customHint1, hint2: customHint2, hint3: customHint3,
            hint4: customHint4, funFact: customFunFact, host: hostUsername,
            createdDate: new Date().toISOString()
        };
        await metadataRef.set(metadataToSave);

        const sanitizedUsername = hostUsername.replace(/[.#$[\]]/g, '_');
        const userProfileRef = database.ref('userProfiles/' + sanitizedUsername);
        const newGameData = {};
        newGameData[`/hostedGames/${secret}`] = { createdDate: metadataToSave.createdDate };
        await userProfileRef.update(newGameData);

    } catch (error) {
        console.error("Firebase save failed:", error);
        return;
    }
    
    localStorage.removeItem('wurtleSetupState');

    const longUrl = generateShareURL(secret, customHint1, customHint2, customHint3, customHint4, customFunFact);
    const shareModal = document.getElementById("share-modal");
    const shareMessageBox = document.getElementById("share-message-box");
    const copyBtn = document.getElementById("copy-url-btn");
    const startBtn = document.getElementById("start-playing-btn");

    shareMessageBox.value = "Creating short link...";
    copyBtn.disabled = true;
    startBtn.disabled = true;
    shareModal.classList.add("show");
    setupDiv.inert = true;

    try {
        const response = await fetch(`https://tinyurl.com/api-create.php?url=${encodeURIComponent(longUrl)}`);
        if (!response.ok) throw new Error('TinyURL service is not available.');
        const shortUrl = await response.text();
        shareMessageBox.value = `Hi! Play my WØRTLE: ${shortUrl}`;
        await metadataRef.update({ shortUrl: shortUrl });
    } catch (error) {
        console.error("Could not shorten URL:", error);
        shareMessageBox.value = `Hi! Play my WØRTLE: ${longUrl}`;
    } finally {
        copyBtn.disabled = false;
        startBtn.disabled = false;
    }

    copyBtn.onclick = () => {
        shareMessageBox.select();
        navigator.clipboard.writeText(shareMessageBox.value).then(() => {
            copyBtn.textContent = "Copied!";
            setTimeout(() => { copyBtn.textContent = "Copy Text"; }, 2000);
        });
    };

    startBtn.onclick = () => {
        shareModal.classList.remove("show");
        window.history.replaceState({}, "", longUrl);
        
        const gameDiv = document.getElementById("game");
        const setupDiv = document.getElementById("setup");
        
        // The setup header is already visible, so we just hide the setup form.
        setupDiv.style.display = "none";
        
        // Show the game board. The header remains visible.
        gameDiv.style.display = "flex";
        gameDiv.style.flexDirection = "column";

        // This will initialize the game state and ensure the header has the correct content.
        checkUserStatus();
    };
}
async function checkUserStatus() {
    let savedUsername = localStorage.getItem("gerNordleUsername");
    const gameElement = document.getElementById("game");
    displayHostCredit();

    if (!savedUsername) {
        window.currentUsername = null;
        loadGameFromStorage();
        return;
    }

    window.currentUsername = savedUsername;
    listenForUserDeletion(savedUsername);

    try {
        const sanitizedUsername = savedUsername.replace(/[.#$[\]]/g, '_');
        const playedGameRef = database.ref(`userProfiles/${sanitizedUsername}/playedGames/${secret}`);
        const playedGameSnapshot = await playedGameRef.once('value');

        if (playedGameSnapshot.exists()) {
            const playedGameData = playedGameSnapshot.val();
            const gameStatus = playedGameData.status;

            if (gameStatus === 'won' || gameStatus === 'lost') {
                gameElement.classList.add("dimmed");
                loadCompletedGame(playedGameData);
                return;
            } 
            // ✅ NEW: If the game is found in Firebase with 'ongoing' status, load it.
            else if (gameStatus === 'ongoing') {
                loadOngoingGame(playedGameData);
                return;
            }
        }
        
        // If no game is found in Firebase, start a fresh game.
        loadGameFromStorage();

    } catch (error) {
        console.error("Firebase completion check failed:", error);
        loadGameFromStorage();
    }
}

function loadGameFromStorage() {
    let savedUsername = localStorage.getItem("gerNordleUsername");
    const gameElement = document.getElementById("game");
    const headerSetup = document.getElementById("header-setup");
    
    const savedPin = localStorage.getItem("gerNordleUserPin");
    if (savedUsername && !savedPin) {
        localStorage.removeItem("gerNordleUsername");
        savedUsername = null;
    }

    initBoard();
    initKeyboard();

    if (savedUsername) {
        // Setup for a brand new game for a logged-in user
        usernameSet = true;
        grid = Array(rows).fill(null).map(() => Array(cols).fill(""));
        guessHistory = [];
        colorHistory = [];
        keyColors = {};
        currentRow = 0;
        currentCol = 0;
        isAnimating = false;
        
        setupUsernameInterface({
            isGamePage: true,
            containerId: 'setup-username-area',
            inputId: 'usernameInputGame',
            placeholder: 'Enter username'
        });
        updateBoard();
        updateKeyboardColors();
        updateHintButtons();
        gameElement.classList.remove("dimmed");
        headerSetup.style.display = 'flex'; // Show the setup header
        gameElement.style.display = 'flex';
    
    } else {
        // Setup for a logged-out user
        updateHintButtons();
        setupUsernameInterface({
            isGamePage: true,
            containerId: 'setup-username-area', // Target the setup header's container
            inputId: 'usernameInputGame',
            placeholder: 'Enter username'
        });
        
        headerSetup.style.display = 'flex'; // Show the setup header
        gameElement.style.display = 'flex';
        gameElement.classList.add("dimmed");
    }
}

function updateBoard() {
  const board = document.getElementById("board");
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      board.children[r].children[c].textContent = grid[r][c];
    }
  }
}

function handleKeyPress(key) {
  if (!usernameSet || isAnimating) {
    return;
  }
  
  const msgEl = document.getElementById("message");
  if (msgEl.textContent.trim() === "You win! 🎉" || msgEl.textContent.trim().startsWith("Game over!")) return;

  const keyButton = document.querySelector(`.key[data-key="${key.toUpperCase()}"]`);
  if (keyButton) {
    keyButton.classList.add("key-pop");
    setTimeout(() => {
      keyButton.classList.remove("key-pop");
    }, 100);
  }

  if (/^[a-zA-ZÄÖÜäöüßẞÆØÅæøå]$/.test(key) && currentCol < cols) {
    let letter = key;
    if (key === "ß") letter = "ẞ";
    else letter = key.toUpperCase();

    grid[currentRow][currentCol] = letter;
    currentCol++;
    updateBoard();
  } else if (key === "Backspace" && currentCol > 0) {
    currentCol--; grid[currentRow][currentCol] = ""; updateBoard();
  } else if (key === "Enter") {
    submitGuess();
  }
}

window.addEventListener("keydown", (e) => {
  if (!usernameSet || isAnimating) return;
  
  if (document.getElementById("game").style.display !== "flex") return;
  const key = e.key.toUpperCase();
  if (key === "BACKSPACE") {
    handleKeyPress("Backspace");
  } else if (key === "ENTER") {
    handleKeyPress("Enter");
  } else if (/^[A-ZÄÖÜßẞÆØÅ]$/.test(key)) {
    const keyToPass = key === 'ß' ? 'ẞ' : key;
    handleKeyPress(keyToPass);
  }
});
function validateHardMode(guess) {
  for (let i = 0; i < guessHistory.length; i++) {
    const prevGuess = guessHistory[i];
    const colors = colorHistory[i];
    
    for (let j = 0; j < cols; j++) {
      if (colors[j] === "correct" && guess[j] !== prevGuess[j]) {
        return `Hard mode violation: Letter '${prevGuess[j]}' must be in position ${j+1}`;
      }
    }

    const presentLetters = {};
    for (let j = 0; j < cols; j++) {
      if (colors[j] === "present") {
        presentLetters[prevGuess[j]] = (presentLetters[prevGuess[j]] || 0) + 1;
      }
    }
    for (const letter in presentLetters) {
      const countInGuess = [...guess].filter(l => l === letter).length;
      if (countInGuess < presentLetters[letter]) {
        return `Hard mode violation: Guess must include letter '${letter}' at least ${presentLetters[letter]} time(s)`;
      }
    }

    for (let j = 0; j < cols; j++) {
      if (colors[j] === "absent") {
        const absentLetter = prevGuess[j];
        const isElsewherePresentOrCorrect = colors.some((color, idx) => 
          (color === "correct" || color === "present") && prevGuess[idx] === absentLetter);
        if (!isElsewherePresentOrCorrect) {
          if (guess.includes(absentLetter)) {
            return `Hard mode violation: Letter '${absentLetter}' cannot be used`;
          }
        }
      }
    }
  }
  return true;
}

async function loadAllWordLists() {
  console.log("Loading all word lists...");

  // Create an array of fetch promises
  const promises = SUPPORTED_LANGUAGES.map(lang => {
    const filePath = `${lang}.txt`; // e.g., "german.txt"
    return fetch(filePath)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Failed to fetch ${filePath}`);
        }
        return response.text();
      });
  });

  try {
    // Wait for all files to be fetched and returned as an array of text content
    const allTexts = await Promise.all(promises);

    // Process each text file's content
    allTexts.forEach(text => {
      const words = text.split(/\s+/); // Splits by any whitespace
      words.forEach(word => {
        if (word) { // Ensure we don't add empty strings
          allValidWords.add(word.trim().toLowerCase());
        }
      });
    });

    console.log(`All word lists loaded! Total valid words: ${allValidWords.size}`);

  } catch (error) {
    console.error("Could not load one or more word lists:", error);
    // Handle the error, maybe show a message to the user
  }
}

function isValidWord(word) {
  // The check is now a simple, fast lookup in the Set.
  // We convert the guessed word to lowercase to ensure case-insensitivity.
  return allValidWords.has(word.toLowerCase());
}

async function submitGuess() {
    const guess = grid[currentRow].join("");
    const currentRowDiv = document.getElementById("board").children[currentRow];

    // This handles all validation checks before proceeding
    if (guess.length !== cols) {
        if (currentRowDiv) {
            currentRowDiv.classList.add("shake");
            setTimeout(() => { currentRowDiv.classList.remove("shake"); }, 500);
        }
        showToast("Not enough letters", "error");
        return;
    }

    if (!isValidWord(guess)) {
        if (currentRowDiv) {
            currentRowDiv.classList.add("shake");
            setTimeout(() => { currentRowDiv.classList.remove("shake"); }, 500);
        }
        showToast("Not in word list", "error");
        return;
    }

    // ✅ FIX: The hard mode validation and its toast message are now handled correctly.
    const hardModeViolation = validateHardMode(guess);
    if (hardModeViolation !== true) { // Check if it returned a string message
        if (currentRowDiv) {
            currentRowDiv.classList.add("shake");
            setTimeout(() => { currentRowDiv.classList.remove("shake"); }, 500);
        }
        showToast(hardModeViolation, "error"); // Use the returned message directly
        return;
    }

    isAnimating = true;
    document.getElementById("message").textContent = "";

    guessHistory.push(guess);
    
    // ...The rest of the function is correct and remains the same...

    const colors = Array(cols).fill("absent");
    const secretLetters = secret.split("");
    for (let i = 0; i < cols; i++) {
        if (guess[i] === secret[i]) {
            colors[i] = "correct";
            secretLetters[i] = null;
        }
    }
    for (let i = 0; i < cols; i++) {
        if (colors[i] === "correct") continue;
        const index = secretLetters.indexOf(guess[i]);
        if (index !== -1) {
            colors[i] = "present";
            secretLetters[index] = null;
        }
    }
    for (let i = 0; i < cols; i++) {
        const letter = guess[i];
        const color = colors[i];
        if (!keyColors[letter] || (color === "correct") || (color === "present" && keyColors[letter] === "absent")) {
            keyColors[letter] = color;
        }
    }

    colorHistory.push(colors);
    updateKeyboardColors();

    const board = document.getElementById("board");
    for (let i = 0; i < cols; i++) {
        const tile = board.children[currentRow].children[i];
        setTimeout(() => {
            tile.classList.add(colors[i]);
        }, i * 200);
    }

    setTimeout(async () => {
        if (guess === secret) {
            endGame(true);
        } else if (currentRow === rows - 1) {
            endGame(false);
        } else {
            currentRow++;
            currentCol = 0;
            isAnimating = false;
            await saveOngoingGame(window.currentUsername, base64Encode(secret));
        }
    }, (cols * 200) + 250);
}

async function endGame(won) {
    hideHintPopup();
    const gameContainer = document.getElementById('game');
    const modalOverlay = document.getElementById('game-over-overlay');
    
    gameContainer.style.opacity = '0';

    try {
        // ✅ The call to updateStats() has been removed from here.
        // All saving logic is now handled by the more robust function below.
        await saveCompletedGameData(won);

    } catch (error) {
        console.error("Failed to save game results to Firebase:", error);
        alert("Your game result could not be saved, but you can still view your stats for this round.");

    } finally {
        // This block for showing the modal remains the same and is safe to run.
        const username = localStorage.getItem("gerNordleUsername");
        const hintStatusForSummary = { hintUsed1, hintUsed2, hintUsed3, hintUsed4 };
        document.getElementById("modal-summary").textContent = generateResultText(true, guessHistory, colorHistory, won, hintStatusForSummary);
        
        if (won) {
            document.getElementById("modal-message").innerHTML = `You win! 🎉<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
        } else {
            document.getElementById("modal-message").innerHTML = `Game over!<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
        }

        const existingFunFact = document.querySelector("#game-over-modal .fun-fact-section");
        if (existingFunFact) existingFunFact.remove();
        if (customFunFact && customFunFact.trim() !== "") {
            const funFactDiv = document.createElement('div');
            funFactDiv.classList.add('fun-fact-section');
            funFactDiv.innerHTML = `<h2>Fun fact about today's Wørtle:</h2><p style="margin:0;">${customFunFact}</p>`;
            document.querySelector("#game-over-modal .modal-content").appendChild(funFactDiv);
        }
        
        const statsContainer = document.getElementById("modal-stats-container");
        statsContainer.innerHTML = "";
        
        const stats = await displayStats(username);
        const statsLines = [ `Stats for ${username}`, `Games Played: ${stats.gamesPlayed}`, `Wins: ${stats.wins}`, `Win %: ${stats.winPct}%`, `Average Guesses: ${stats.avgGuesses}`];
        statsLines.forEach(line => {
            const p = document.createElement("p");
            p.textContent = line;
            p.classList.add("stats-line");
            statsContainer.appendChild(p);
        });

        bindModalButtons(guessHistory, colorHistory, won, hintStatusForSummary);
        modalOverlay.classList.add('show');

        setTimeout(() => {
            const messageEl = document.getElementById("message");
            const board = document.getElementById('board');
            if (won) {
                messageEl.innerHTML = "You win! 🎉";
            } else {
                messageEl.innerHTML = `Game over! The word was ${secret}.`;
            }
            messageEl.classList.add('visible');
            const historyHtml = generateGuessHistoryHTML(guessHistory, colorHistory);
            board.innerHTML = historyHtml;
            board.style.gridTemplateRows = 'none';
            disableKeyboard();
            gameContainer.style.opacity = '0.5';
            gameContainer.style.pointerEvents = 'none';
        }, 400);
    }
}

function disableKeyboard() {
  // Disable all on-screen keys
  document.querySelectorAll('.key').forEach(keyBtn => {
    keyBtn.disabled = true;
  });
  // Use the existing isAnimating flag to block physical keyboard input
  isAnimating = true; 
}

function initBoard() {
  const board = document.getElementById("board");
  board.innerHTML = "";
  for (let r = 0; r < rows; r++) {
    const rowDiv = document.createElement("div");
    rowDiv.classList.add("row");
    for (let c = 0; c < cols; c++) {
      const tileDiv = document.createElement("div");
      tileDiv.classList.add("tile");
      rowDiv.appendChild(tileDiv);
    }
    board.appendChild(rowDiv);
  }
}

function initKeyboard() {
  const keyboardDiv = document.getElementById("keyboard");
  keyboardDiv.innerHTML = "";
  const keysLayout = [
    ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "Å"],
    ["A", "S", "D", "F", "G", "H", "J", "K", "L", "Ö", "Ä", "Ø"],
    ["Enter", "Z", "X", "C", "V", "B", "N", "M", "Ü", "ẞ", "Æ", "Backspace"]
  ];

  keysLayout.forEach(row => {
    const rowDiv = document.createElement("div");
    rowDiv.classList.add("key-row");
    row.forEach(key => {
      const keyBtn = document.createElement("button");
      keyBtn.textContent = key;
      keyBtn.classList.add("key");
      keyBtn.dataset.key = key;
      keyBtn.onclick = () => handleKeyPress(key);
      rowDiv.appendChild(keyBtn);
    });
    keyboardDiv.appendChild(rowDiv);
  });
}

function updateKeyboardColors() {
    for (const key in keyColors) {
        const keyBtn = document.querySelector(`.key[data-key="${key}"]`);
        if (keyBtn) {
            keyBtn.classList.remove("present", "absent", "correct"); // Clear old colors
            keyBtn.classList.add(keyColors[key]);
        }
    }
}

function showHint(hintNumber) {
    let btn, hintText, hintContent;
    
    switch(hintNumber) {
        case 1:
            btn = document.getElementById('hintBtn1');
            hintContent = customHint1;
            if (hintUsed1) return; 
            hintUsed1 = true; 
            hintExpanded1 = true;
            break;
        case 2:
            btn = document.getElementById('hintBtn2');
            hintContent = customHint2;
            if (hintUsed2) return; 
            hintUsed2 = true; 
            hintExpanded2 = true;
            break;
        case 3:
            btn = document.getElementById('hintBtn3');
            hintContent = customHint3;
            if (hintUsed3) return; 
            hintUsed3 = true; 
            hintExpanded3 = true;
            break;
        case 4:
            btn = document.getElementById('hintBtn4');
            hintContent = customHint4;
            if (hintUsed4) return; 
            hintUsed4 = true; 
            hintExpanded4 = true;
            break;
    }

    if (btn && !btn.classList.contains('expanded')) {
        hintText = btn.querySelector('.hint-text');
        hintText.textContent = hintContent;
        btn.classList.add('expanded');
        hintText.classList.add('visible');
        btn.classList.add('clicked-hint');
        btn.disabled = true;
    }
    
    // ✅ Add this line to save the game state immediately
    if (window.currentUsername && secret) {
        saveOngoingGame(window.currentUsername, base64Encode(secret));
    }
}

function generateResultText(isForDisplay, history, colors, won, hintStatus) {
    // Get and format the current date
    const dateToUse = gameCreatedDate || new Date();
    const options = { year: 'numeric', month: 'short', day: 'numeric' };
    const dateString = dateToUse.toLocaleDateString('en-GB', options);

    // The first line of the result text
    let text = `WØRTLE (${won ? history.length : 'X'}/6)\n`;
    
    // Add the formatted date on the next line
    text += `${dateString}\n`;

    // Count the total number of hints used
    let hintCount = 0;
    if (hintStatus.hintUsed1) hintCount++;
    if (hintStatus.hintUsed2) hintCount++;
    if (hintStatus.hintUsed3) hintCount++;
    if (hintStatus.hintUsed4) hintCount++;

    // Add the emoji grid (this part remains the same)
    const colorMap = {
        correct: '🟩',
        present: '🟨',
        absent: '⬛'
    };

    for (let i = 0; i < colors.length; i++) {
        let rowText = colors[i].map(color => colorMap[color] || '⬛').join('');
        text += rowText + '\n';
    }

    // Add the hint summary sentence if any hints were used, followed by a blank line
    if (hintCount === 1) {
        text += "1 hint used\n";
    } else if (hintCount > 1) {
        text += `${hintCount} hints used\n`;
    } else {
        // If no hints were used, just add a blank line for spacing
        text += "\n";
    }

    return text;
}

function resetHints() {
    hintUsed1 = hintUsed2 = hintUsed3 = hintUsed4 = false;
    hintExpanded1 = hintExpanded2 = hintExpanded3 = hintExpanded4 = false; // Reset new variables
    ['hintBtn1', 'hintBtn2', 'hintBtn3', 'hintBtn4'].forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            btn.classList.remove('expanded', 'clicked-hint');
            btn.disabled = false;
            const hintTextSpan = btn.querySelector('.hint-text');
            if(hintTextSpan) {
              hintTextSpan.classList.remove('visible');
              hintTextSpan.textContent = '';
            }
            const hintLabel = btn.querySelector('.hint-label');
            if (hintLabel) {
                hintLabel.classList.remove('hidden');
            }
        }
    });
}
window.onload = async () => {
    const loader = document.getElementById('loader');
    secret = getSecretFromURL();
    const setupDiv = document.getElementById("setup");
    const gameDiv = document.getElementById("game");
    const messageEl = document.getElementById("message");
    const headerSetup = document.getElementById("header-setup");
    gameDiv.style.display = "none";
    headerSetup.style.display = "none";
    setupDiv.style.display = "none";

    // Case 1: A secret word is present in the URL
    if (secret) {
        const gameRef = database.ref('games/' + secret);
        const snapshot = await gameRef.once('value');

        loader.style.display = 'none'; // Hide loader

        if (snapshot.exists()) {
            // If the game exists, load the game UI
            headerSetup.style.display = "flex"; // Use the correct header
            gameDiv.style.display = "flex";
            gameDiv.style.flexDirection = "column"; 
            checkUserStatus();
        } else {
            // If the game does NOT exist, show the error message
            messageEl.innerHTML = `The game you are looking for does not exist or has been deleted.<br><br><a href="/wordle.html" style="color: white; text-decoration: underline;">Create a new game</a>`;
            messageEl.style.marginTop = '50px';
        }

    } else {
        // Case 2: No secret word in the URL, show the setup/host page
        loader.style.display = 'none'; // Hide loader
        headerSetup.style.display = "flex";
        setupDiv.style.display = "block";
    
        const savedUsername = localStorage.getItem("gerNordleUsername");
        if (savedUsername) {
            listenForUserDeletion(savedUsername);
        }
        
        setupUsernameInterface({
            isGamePage: false,
            containerId: 'setup-username-area',
            inputId: 'usernameInputHost',
            placeholder: 'Enter username'
        });
        loadSetupState();
        
        const setupInputs = [
            document.getElementById('secretInput'),
            document.getElementById('hintInput'),
            document.getElementById('hintInput2'),
            document.getElementById('hintInput3'),
            document.getElementById('funFactInput')
        ];
        setupInputs.forEach(input => input.addEventListener('input', saveSetupState));
        document.querySelectorAll('.specialCharCheckbox').forEach(cb => cb.addEventListener('change', saveSetupState));
    }

    // This listener is for the host page
    const secretInput = document.getElementById('secretInput');
    if (secretInput) {
        secretInput.addEventListener('input', () => {
            clearTimeout(debounceTimer);
            const indicator = document.getElementById('word-status-indicator');
            indicator.innerHTML = ''; 
            indicator.className = 'loading'; 
            debounceTimer = setTimeout(() => {
                validateSecretWord();
            }, 500); 
        });
    }
};

async function saveOngoingGame(username, encodedSecret) {
    if (!username || !encodedSecret) return;
    
    const word = base64Decode(encodedSecret);
    if (!word) return;

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const playedGameRef = database.ref(`userProfiles/${sanitizedUsername}/playedGames/${word}`);

    // First, check for an existing record to preserve the original createdDate
    const snapshot = await playedGameRef.once('value');
    const existingData = snapshot.val();
    const createdDate = existingData?.createdDate || new Date().toISOString();

    // Package the entire current game state
    const ongoingStateForFirebase = {
        status: 'ongoing',
        createdDate: createdDate,
        lastPlayedDate: new Date().toISOString(), // Useful for sorting later
        grid: grid,
        currentRow: currentRow,
        guessHistory: guessHistory,
        colorHistory: colorHistory,
        keyColors: keyColors,
        hintStatus: { hintUsed1, hintUsed2, hintUsed3, hintUsed4, hintExpanded1, hintExpanded2, hintExpanded3, hintExpanded4 }
    };

    // Use .set() to save the complete ongoing state to Firebase
    await playedGameRef.set(ongoingStateForFirebase);

    // The logic to add a player to the central /games list on their first guess remains
    const isFirstGuess = guessHistory.length === 1;
    if (isFirstGuess) {
        const centralPlayerListRef = database.ref(`games/${word}/players/${sanitizedUsername}`);
        await centralPlayerListRef.set(true);
    }
    
    // We still save to local storage for quick refreshes on the same device
    const allGameData = JSON.parse(localStorage.getItem("gerNordleGameData") || "{}");
    if (!allGameData[username]) allGameData[username] = {};
    allGameData[username][encodedSecret] = {
        ongoingState: ongoingStateForFirebase, // Save the same object
        createdDate: createdDate
    };
    localStorage.setItem("gerNordleGameData", JSON.stringify(allGameData));
}

const helpBtn = document.getElementById("helpBtn");
const helpPopup = document.getElementById("helpPopup");
const closeHelpBtn = document.getElementById("closeHelpBtn");
const helpOverlay = document.getElementById("helpOverlay");
const mainContent = document.getElementById("mainContent");

function showHelpPopup() {
  helpPopup.hidden = false;
  helpOverlay.hidden = false;
  mainContent.inert = true;
  mainContent.setAttribute('aria-hidden', 'true');
  setInputsDisabled(true);
  helpPopup.focus();
}

function hideHelpPopup() {
  helpPopup.hidden = true;
  helpOverlay.hidden = true;
  mainContent.inert = false;
  mainContent.removeAttribute('aria-hidden');
  setInputsDisabled(false);
}

// Find the new button in the document
const newGameBtn = document.getElementById("newGameBtn");

// This function navigates to the base URL of your site
function goToHostPage() {
  // window.location.origin provides the base URL (e.g., "https://your-site.com")
  window.location.href = window.location.origin + window.location.pathname;
}

// Attach the function to the button's click event
if (newGameBtn) {
  newGameBtn.addEventListener("click", goToHostPage);
}

helpBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  if (helpPopup.hidden) {
    showHelpPopup();
  } else {
    hideHelpPopup();
  }
});

closeHelpBtn.addEventListener("click", () => {
  hideHelpPopup();
});

helpOverlay.addEventListener("click", () => {
  hideHelpPopup();
});

// Global keydown: block all keys except Ctrl/Meta shortcuts and Escape when popup is visible
document.addEventListener("keydown", (event) => {
  if (!helpPopup.hidden) {
    // Allow Escape to close popup
    if (event.key === "Escape") {
      return;
    }

    // For Cmd/Ctrl + key combos like Cmd+C:
    if (event.ctrlKey || event.metaKey) {
      // Stop propagation to prevent Wordle input, but allow native shortcut
      event.stopImmediatePropagation();
      // Don't preventDefault here so native shortcut works
      return;
    }

    // Block all other keys completely (typing)
    event.preventDefault();
    event.stopImmediatePropagation();
  }
}, true);

// Also block typing on Wordle input elements specifically except shortcuts and Escape
const wordleInputs = mainContent.querySelectorAll('input, textarea, [contenteditable="true"]');
wordleInputs.forEach(input => {
  input.addEventListener('keydown', (event) => {
    if (!helpPopup.hidden) {
      if (event.ctrlKey || event.metaKey || event.key === "Escape") {
        return; // allow shortcuts and Escape
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    }
  }, true);
});

// Optional: allow Escape to close popup (already handled above, but keep if needed)
document.addEventListener("keydown", (event) => {
  if (!helpPopup.hidden && event.key === "Escape") {
    hideHelpPopup();
  }
});

// Prevent clicks inside popup from closing it
helpPopup.addEventListener("click", (event) => {
  event.stopPropagation();
});

function setInputsDisabled(state) {
  // Select all inputs, textareas, and contenteditable elements inside mainContent
  const inputs = mainContent.querySelectorAll('input, textarea, [contenteditable="true"], button, select');
  inputs.forEach(el => {
    el.disabled = state;
    if (state) {
      el.setAttribute('aria-disabled', 'true');
      el.blur(); // remove focus when disabling
    } else {
      el.removeAttribute('aria-disabled');
    }
  });
}
function updateHintButtons() {
    const hintBtn1 = document.getElementById("hintBtn1");
    const hintBtn2 = document.getElementById("hintBtn2");
    const hintBtn3 = document.getElementById("hintBtn3");
    const hintBtn4 = document.getElementById("hintBtn4");

    // Hide all hint buttons by default.
    hintBtn1.style.display = "none";
    hintBtn2.style.display = "none";
    hintBtn3.style.display = "none";
    hintBtn4.style.display = "none";

    let hasAnyHints = false; // Track if any hints are available

    // Helper function to restore a single hint button's state
    function restoreHintButton(btn, hintContent, used, expanded) {
        if (hintContent && hintContent.trim() !== "") {
            hasAnyHints = true; // Mark that we have at least one hint

            // Show the button in the pop-up.
            btn.style.display = "inline-flex";

            if (used) {
                btn.classList.add('clicked-hint');
                btn.disabled = true;

                if (expanded) {
                    const hintTextSpan = btn.querySelector('.hint-text');
                    if (hintTextSpan) {
                        hintTextSpan.textContent = hintContent;
                        hintTextSpan.classList.add('visible');
                    }
                    btn.classList.add('expanded');
                    btn.querySelector('.hint-label').classList.add('hidden');
                }
            } else {
                btn.disabled = false;
                btn.classList.remove('clicked-hint', 'expanded');
                const hintTextSpan = btn.querySelector('.hint-text');
                if (hintTextSpan) {
                    hintTextSpan.classList.remove('visible');
                    hintTextSpan.textContent = ""; // Clear hidden hint text
                }
                btn.querySelector('.hint-label').classList.remove('hidden');
            }
        }
    }

    // Apply restoration logic for each hint button
    restoreHintButton(hintBtn1, customHint1, hintUsed1, hintExpanded1);
    restoreHintButton(hintBtn2, customHint2, hintUsed2, hintExpanded2);
    restoreHintButton(hintBtn3, customHint3, hintUsed3, hintExpanded3);
    restoreHintButton(hintBtn4, customHint4, hintUsed4, hintExpanded4);

    // Show or hide the "Need a hint?" container based on availability
    document.getElementById("hintButtons").style.display = hasAnyHints ? "block" : "none";
}

function bindModalButtons(savedGuessHistory, savedColorHistory, isSolved, savedHintStatus) {
    const modalCopyBtn = document.getElementById("modalCopyBtn");
    const showStatsBtn = document.getElementById("showStatsBtn");
    const showScoreboardBtn = document.getElementById("showScoreboardBtn");
    const closeModalBtn = document.getElementById("closeModalBtn"); // --- Find the new button

    // --- ADD THIS BLOCK ---
    if (closeModalBtn) {
        closeModalBtn.onclick = closeGameOverModal;
    }

    // --- 1. Copy Result Button ---
    if (modalCopyBtn) {
        modalCopyBtn.onclick = () => {
            const resultText = generateResultText(false, savedGuessHistory, savedColorHistory, isSolved, savedHintStatus);
            navigator.clipboard.writeText(resultText).then(() => {
                modalCopyBtn.innerHTML = "<i>Copied!</i>";
                modalCopyBtn.disabled = true;
                setTimeout(() => {
                    modalCopyBtn.innerHTML = "Copy Result";
                    modalCopyBtn.disabled = false;
                }, 1500);
            });
        };
    }

    // --- 2. Stats Toggle Button ---
    if (showStatsBtn) {
        showStatsBtn.onclick = () => {
            const statsContainer = document.getElementById("modal-stats-container");
            statsContainer.classList.toggle('expanded');
            showStatsBtn.textContent = statsContainer.classList.contains('expanded') ? "Hide My Stats" : "Show My Stats";
        };
    }

    // --- 3. View/Hide Scoreboard Button (MODIFIED) ---
    if (showScoreboardBtn) {
        // Set initial text
        showScoreboardBtn.textContent = "View Scoreboard";
        
        showScoreboardBtn.onclick = () => {
            const scoreboardPanel = document.getElementById('scoreboard-panel');
            // Check if the panel is already visible
            if (scoreboardPanel.classList.contains('show')) {
                hideScoreboard(); // If yes, hide it
            } else {
                showScoreboard(); // If no, show it
            }
        };
    }
}

function showHintPopup() {
  hintPopup.classList.add("show");
  document.addEventListener("keydown", handleTypingToClose);
}

function hideHintPopup() {
  hintPopup.classList.remove("show");
  document.removeEventListener("keydown", handleTypingToClose);
}
// Event listeners for the hint popup
if (hintTitle) {
  hintTitle.addEventListener("click", showHintPopup);
}
if (closeHintPopupBtn) {
  closeHintPopupBtn.addEventListener("click", hideHintPopup);
}

// This handles the "click outside" functionality
if (hintPopupOverlay) {
  hintPopupOverlay.addEventListener("click", hideHintPopup);
}

// This prevents clicks *inside* the popup from closing it
if (hintPopup) {
  hintPopup.addEventListener("click", (event) => {
    event.stopPropagation();
  });
}
// --- Add this new function to your script ---

async function generateRandomWord() {
  const generateBtn = document.getElementById("generateWordBtn");
  const secretInput = document.getElementById("secretInput");
  const indicator = document.getElementById("word-status-indicator");

  if (allValidWords.size === 0) {
    showToast("Word lists are still loading. Please wait a moment and try again.", "error");
    return;
  }

  // Set the UI to a "loading" state
  if (generateBtn) generateBtn.disabled = true;
  secretInput.value = '';
  indicator.innerHTML = '';
  indicator.className = 'loading';

  const allWordsArray = [...allValidWords];
  let foundWord = null;
  let attempts = 0;
  const maxAttempts = 50; // Safety limit to prevent an infinite loop
  let hadError = false;

  while (!foundWord && attempts < maxAttempts) {
    attempts++;
    const randomIndex = Math.floor(Math.random() * allWordsArray.length);
    const randomWord = allWordsArray[randomIndex].toUpperCase();

    try {
      const gameRef = database.ref('games/' + randomWord);
      const snapshot = await gameRef.once('value');
      if (!snapshot.exists()) {
        foundWord = randomWord; // We found an available word!
      }
    } catch (error) {
      console.error("Database error while finding a random word:", error);
      hadError = true;
      break; // Exit the loop on a database error
    }
  }

  // --- Final UI update after the search is complete ---

  // Always remove the loading spinner
  indicator.className = '';
  indicator.innerHTML = '';

  if (foundWord) {
    secretInput.value = foundWord;
  } else {
    // If we failed, show an error icon briefly
    console.warn("Could not find an available random word after several attempts.");
    if (hadError) {
        indicator.innerHTML = '⚠️';
        indicator.className = 'invalid';
        // Clear the error icon after a few seconds
        setTimeout(() => { indicator.innerHTML = ''; indicator.className = ''; }, 2500);
    }
  }

  // Always re-enable the button
  if (generateBtn) generateBtn.disabled = false;
}

// --- Add this event listener to make the button work ---

// Find the new button in the document
const generateBtn = document.getElementById("generateWordBtn");

// Attach the function to the button's click event
if (generateBtn) {
  generateBtn.addEventListener("click", generateRandomWord);
}

// --- Find the new scoreboard elements ---
const scoreboardPanel = document.getElementById('scoreboard-panel');

function showScoreboard() {
  const showScoreboardBtn = document.getElementById('showScoreboardBtn');
  // First, fetch the data and populate the panel
  fetchAndDisplayScoreboard();
  // Then, slide the panel into view
  scoreboardPanel.classList.add('show');
  // Update button text
  if (showScoreboardBtn) {
    showScoreboardBtn.textContent = 'Hide Scoreboard';
  }
}

// This function now hides the side panel
function hideScoreboard() {
  const showScoreboardBtn = document.getElementById('showScoreboardBtn');
  scoreboardPanel.classList.remove('show');
  
  // Reset the button text
  if (showScoreboardBtn) {
    showScoreboardBtn.textContent = 'View Scoreboard';
  }
  
  // Clean up the real-time listener to prevent memory leaks
  if (scoreboardListener && secret) {
      const gameRef = database.ref('games/' + secret);
      gameRef.off('value', scoreboardListener);
      scoreboardListener = null; // Clear the variable
  }
}

function fetchAndDisplayScoreboard() {
    if (!secret) return;

    const container = document.getElementById('scoreboard-container');
    const wordDisplay = document.getElementById('scoreboard-word');
    const summaryContainer = document.getElementById('scoreboard-summary-container');
    
    if (!container || !wordDisplay || !summaryContainer) {
        console.error("Scoreboard HTML elements not found! Check your element IDs.");
        return; 
    }

    const gameRef = database.ref('games/' + secret);

    wordDisplay.textContent = secret;
    container.innerHTML = '<p>Loading scores...</p>';
    summaryContainer.innerHTML = '';

    if (scoreboardListener) {
        gameRef.off('value', scoreboardListener);
    }
    
    scoreboardListener = gameRef.on('value', (snapshot) => {
        const scoresData = snapshot.val();

        if (!scoresData) {
            container.innerHTML = '<p>Be the first to set a score!</p>';
            return;
        }

        // ✅ Step 1: Get the host's name from the game's metadata.
        const hostName = scoresData.metadata ? scoresData.metadata.host : null;

        const playerScores = Object.keys(scoresData)
            .filter(key => key !== 'metadata' && key !== 'players') 
            .map(key => scoresData[key]);

        if (playerScores.length === 0) {
            container.innerHTML = '<p>Be the first to set a score!</p>';
            summaryContainer.innerHTML = ''; 
            return;
        }
        
        const totalPlayers = playerScores.length;
        const winners = playerScores.filter(score => score.guesses > 0);
        const totalWinners = winners.length;
        const solveRate = totalPlayers > 0 ? (totalWinners / totalPlayers) * 100 : 0;
        const totalGuesses = winners.reduce((sum, player) => sum + player.guesses, 0);
        const avgGuesses = totalWinners > 0 ? totalGuesses / totalWinners : 0;

        summaryContainer.innerHTML = `
            <div class="summary-stat">
                <span class="stat-label">Solve Rate</span>
                <div class="stat-bar-container">
                    <div class="stat-bar" style="width: ${solveRate.toFixed(1)}%;">${solveRate.toFixed(1)}%</div>
                </div>
            </div>
            <div class="summary-stat">
                <span class="stat-label">Avg. Guesses</span>
                <div class="stat-bar-container">
                    <div class="stat-bar" style="width: ${(avgGuesses / 6) * 100}%;">${avgGuesses.toFixed(1)}</div>
                </div>
            </div>
        `;

        winners.sort((a, b) => {
            const guessDifference = a.guesses - b.guesses;
            if (guessDifference !== 0) return guessDifference;
            return (a.hintCount || 0) - (b.hintCount || 0);
        });

        const losers = playerScores.filter(score => score.guesses <= 0);
        const sortedScores = [...winners, ...losers];

        let tableHTML = `
            <table>
                <thead><tr><th>Rank</th><th>Player</th><th>Guesses</th><th>Hints</th></tr></thead>
                <tbody>`;

        sortedScores.forEach((score, index) => {
            const guessDisplay = score.guesses > 0 ? score.guesses : 'X';

            // ✅ Step 2: Check if the current player is the host and prepare the display name.
            let nameDisplay = score.username;
            if (hostName && score.username === hostName) {
                nameDisplay += ` <span style="color: #951414; font-weight: bold;">H</span>`;
            }

            // ✅ Step 3: Use the new display name in the table row.
            tableHTML += `
                <tr>
                    <td>${index + 1}</td>
                    <td>${nameDisplay}</td>
                    <td>${guessDisplay}</td>
                    <td>${score.hintCount || 0}</td>
                </tr>`;
        });

        tableHTML += '</tbody></table>';
        container.innerHTML = tableHTML;

    }, (error) => {
        console.error("Firebase listener error:", error);
        container.innerHTML = '<p>Could not load scores due to an error.</p>';
        summaryContainer.innerHTML = '<p style="text-align:center; color:#c7d1d5;">Could not load stats.</p>';
    });
}

function closeGameOverModal() {
  const overlay = document.getElementById('game-over-overlay');
  if (overlay) {
    overlay.classList.remove('show');
  }
  hideScoreboard();
}

function generateGuessHistoryHTML(guessHistory, colorHistory) {
  let historyHtml = '';
  
  // Loop through each guess
  for (let i = 0; i < guessHistory.length; i++) {
    const guess = guessHistory[i];
    const colors = colorHistory[i];
    historyHtml += '<div class="row">';
    // Loop through each letter in the guess
    for (let j = 0; j < guess.length; j++) {
      const letter = guess[j];
      const colorClass = colors[j]; // 'correct', 'present', or 'absent'
      // Create a tile with the original classes for styling
      historyHtml += `<div class="tile ${colorClass}">${letter}</div>`;
    }
    historyHtml += '</div>';
  }
  return historyHtml;
}

async function loginUser(inputId, pinInputId, config) {
    const usernameInput = document.getElementById(inputId);
    const pinInput = document.getElementById(pinInputId);
    const username = usernameInput.value.trim().toUpperCase();
    const pin = pinInput.value.trim();

    if (!username || !pin) {
        showToast("Please enter both a username and a PIN.", "error");
        return;
    }
    if (username.length > 10) {
        showToast("Username cannot be more than 10 characters long.", "error");
        return;
    }

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const userRef = database.ref('users/' + sanitizedUsername);

    try {
        const snapshot = await userRef.once('value');
        if (snapshot.exists()) {
            const userData = snapshot.val();
            if (userData.pin === pin) {
                // PIN is correct! Log the user in.
                localStorage.setItem("gerNordleUsername", username);
                localStorage.setItem("gerNordleUserPin", pin); 
                window.location.reload();
                // Refresh the UI
                if (config.isGamePage) {
                    checkUserStatus();
                } else {
                    setupUsernameInterface(config);
                }
            } else {
                showToast("Incorrect PIN. Please try again.", "error");
            }
        } else {
            showToast(`Username "${username}" does not exist. Please register first.`, "error");
        }
    } catch (error) {
        console.error("Login error:", error);
        showToast("Could not log in. Please check your connection.", "error");
    }
}

async function registerUser(inputId, pinInputId, config) {
    const usernameInput = document.getElementById(inputId);
    const pinInput = document.getElementById(pinInputId);
    const username = usernameInput.value.trim().toUpperCase();
    const pin = pinInput.value.trim();

    if (!username || !pin) {
        showToast("Please enter both a username and a PIN.", "error");
        return;
    }
    if (username.length < 3) {
        showToast("Username must be at least 3 characters long.", "error");
        return;
    }
    if (username.length > 10) {
        showToast("Username cannot be more than 10 characters long.", "error");
        return;
    }
    if (pin.length !== 4 || isNaN(pin)) {
        showToast("Your PIN must be 4 digits.", "error");
        return;
    }

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const userRef = database.ref('users/' + sanitizedUsername);

    try {
        const snapshot = await userRef.once('value');
        if (snapshot.exists()) {
            showToast(`The username "${username}" is already taken. Please try logging in or choose another name.`, "error");
        } else {
            // Username is available, register it with the PIN.
            await userRef.set({
                original: username,
                pin: pin, // Store the PIN
                registeredAt: firebase.database.ServerValue.TIMESTAMP
            });

            // Automatically log the user in after registration.
            localStorage.setItem("gerNordleUsername", username);
            localStorage.setItem("gerNordleUserPin", pin);
            window.location.reload();
            
            // Refresh the UI
            if (config.isGamePage) {
                checkUserStatus();
            } else {
                setupUsernameInterface(config);
            }
        }
    } catch (error) {
        console.error("Registration error:", error);
        showToast("Could not register username. Please try again.", "error");
    }
}

function setupUsernameInterface(config) {
    const { isGamePage, containerId, inputId, placeholder } = config;
    const pinInputId = inputId + '-pin';
    const container = document.getElementById(containerId);
    if (!container) return;

    const savedUsername = localStorage.getItem("gerNordleUsername");
    
    // Clear the specific container we're working with.
    container.innerHTML = ''; 
    // Remove any special layout classes before we start
    container.classList.remove('login-prompt-container');

    if (savedUsername) {
        // This block now correctly handles the display for a LOGGED-IN user on BOTH pages.
        const displayMessage = document.createElement("p");
        displayMessage.textContent = `Logged in as: ${savedUsername.toUpperCase()}`;

        const changeButton = document.createElement("button");
        changeButton.textContent = "Change User";
        changeButton.onclick = () => {
                document.getElementById('game').classList.add('dimmed');
                document.getElementById('setup-form-content').classList.add('dimmed');
                stopUserDeletionListener();
                localStorage.removeItem("gerNordleUsername");
                localStorage.removeItem("gerNordleUserPin");
                setupUsernameInterface(config);
            };
        changeButton.classList.add("styled-button");

        container.appendChild(displayMessage);
        container.appendChild(changeButton);

        // Only interact with the setup form if we are on the setup page.
        if (!isGamePage) {
            document.getElementById('setup-form-content').classList.remove('dimmed');
        }
    } else {
        // This block handles the display for a LOGGED-OUT user.
        if (!isGamePage) {
            document.getElementById('setup-form-content').classList.add('dimmed');
        }

        // ✨ APPLY THE NEW CLASS to the container
        container.classList.add('login-prompt-container');
        
        const usernameInput = document.createElement("input");
        usernameInput.type = "text";
        usernameInput.id = inputId;
        usernameInput.placeholder = placeholder;
        usernameInput.maxLength = 10; 
        usernameInput.style.cssText = "padding: 3px 6px; border-radius: 6px; margin: 0px; width: 140px;";

        const pinInput = document.createElement("input");
        pinInput.type = "password";
        pinInput.id = pinInputId;
        pinInput.placeholder = "4-digit PIN";
        pinInput.maxLength = 4;
        pinInput.style.cssText = "padding: 3px 6px; border-radius: 6px; margin: 0px; width: 100px;";

        const loginButton = document.createElement("button");
        loginButton.textContent = "Login";
        loginButton.classList.add("styled-button");
        loginButton.onclick = () => loginUser(inputId, pinInputId, config);

        const registerButton = document.createElement("button");
        registerButton.textContent = "Register";
        registerButton.classList.add("styled-button");
        registerButton.onclick = () => registerUser(inputId, pinInputId, config);

        const handleEnterKey = (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                loginButton.click(); 
            }
        };
        usernameInput.addEventListener('keydown', handleEnterKey);
        pinInput.addEventListener('keydown', handleEnterKey);
        
        // Append the new login elements to the container.
        container.appendChild(usernameInput);
        container.appendChild(pinInput);
        container.appendChild(loginButton);
        container.appendChild(registerButton);
        
        window.currentUsername = null;
        usernameSet = false;
    }
}

// This helper function displays the game-over modal with the correct information.
async function showGameOverModal(isSolved, guessHistory, colorHistory, hintStatus) {
    const overlay = document.getElementById("game-over-overlay");
    
    // Set win/loss message
    if (isSolved) {
        document.getElementById("modal-message").innerHTML = `You win! 🎉<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
    } else {
        document.getElementById("modal-message").innerHTML = `Game over!<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
    }

    // Generate and display the shareable summary
    document.getElementById("modal-summary").textContent = generateResultText(true, guessHistory, colorHistory, isSolved, hintStatus);

    // Display the fun fact, if one exists
    const existingFunFact = document.querySelector("#game-over-modal .fun-fact-section");
    if (existingFunFact) existingFunFact.remove();
    if (customFunFact && customFunFact.trim() !== "") {
        const funFactDiv = document.createElement('div');
        funFactDiv.classList.add('fun-fact-section');
        funFactDiv.innerHTML = `<h2>Fun fact about today's Wørtle:</h2><p style="margin:0;">${customFunFact}</p>`;
        document.querySelector("#game-over-modal .modal-content").appendChild(funFactDiv);
    }

    // Display user stats
    const statsContainer = document.getElementById("modal-stats-container");
    statsContainer.innerHTML = "";
    const username = localStorage.getItem("gerNordleUsername");
    const stats = await displayStats(username);
    const statsLines = [
        `Stats for ${username}`,
        `Games Played: ${stats.gamesPlayed}`,
        `Wins: ${stats.wins}`,
        `Win %: ${stats.winPct}%`,
        `Average Guesses: ${stats.avgGuesses}`
    ];

    statsLines.forEach(line => {
        const p = document.createElement("p");
        p.textContent = line;
        p.classList.add("stats-line");
        statsContainer.appendChild(p);
    });

    // Bind buttons and show the modal
    bindModalButtons(guessHistory, colorHistory, isSolved, hintStatus);
    overlay.classList.add('show');
}
// --- Account Sidebar Logic ---
const accountBtn = document.getElementById('accountBtn');
const accountSidebar = document.getElementById('account-sidebar');
const accountOverlay = document.getElementById('account-overlay');
const closeAccountBtn = document.getElementById('closeAccountBtn');
const hostedGamesList = document.getElementById('hosted-games-list');
const playedGamesList = document.getElementById('played-games-list');
let resolveHostedGames = null;
let resolvePlayedGames = null;

// Define references in a higher scope to manage them across open/close actions
let hostedGamesRef = null;
let playedGamesRef = null;

function renderHostedGames(snapshot) {
    hostedGamesList.innerHTML = '';
    const titleElement = document.getElementById('hosted-games-title');

    if (!snapshot.exists()) {
        if (titleElement) titleElement.textContent = 'Hosted Games (0)';
        hostedGamesList.innerHTML = '<p style="padding: 10px;">You have not created any games.</p>';
        // ✅ Signal that loading is complete, even if the list is empty.
        if (resolveHostedGames) {
            resolveHostedGames();
            resolveHostedGames = null;
        }
        return;
    }

    const gamesObject = snapshot.val();
    const games = [];
    for (const word in gamesObject) {
        games.push({ word: word, ...gamesObject[word] });
    }
    
    if (titleElement) titleElement.textContent = `My Games (${games.length})`;

    if (games.length === 0) {
        hostedGamesList.innerHTML = '<p style="padding: 10px;">You have not created any games.</p>';
        // ✅ Signal that loading is complete for an empty list.
        if (resolveHostedGames) {
            resolveHostedGames();
            resolveHostedGames = null;
        }
        return;
    }

    games.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));
    const metaPromises = games.map(game => database.ref(`games/${game.word}/metadata`).once('value'));

    Promise.all(metaPromises).then(metaSnapshots => {
        const fragment = document.createDocumentFragment();
        metaSnapshots.forEach((metaSnap, idx) => {
            if (metaSnap.exists()) {
                const meta = metaSnap.val();
                const listItem = document.createElement('div');
                listItem.className = 'game-list-item';
                const gameLink = document.createElement('a');
                const fullUrl = generateShareURL(meta.word, meta.hint1, meta.hint2, meta.hint3, meta.hint4, meta.funFact);
                gameLink.href = fullUrl;
                gameLink.textContent = meta.word;
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'game-item-actions';
                const copyBtn = document.createElement('button');
                copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>`;
                copyBtn.title = 'Copy Link';
                copyBtn.onclick = () => {
                    const urlToCopy = meta.shortUrl || fullUrl;
                    navigator.clipboard.writeText(urlToCopy).then(() => {
                        copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
                        setTimeout(() => {
                            copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>`;
                        }, 2000);
                    });
                };
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
                deleteBtn.title = 'Delete Game';
                deleteBtn.onclick = () => deleteGame(meta.word);
                actionsDiv.appendChild(copyBtn);
                actionsDiv.appendChild(deleteBtn);
                listItem.appendChild(gameLink);
                listItem.appendChild(actionsDiv);
                fragment.appendChild(listItem);
            }
        });
        hostedGamesList.appendChild(fragment);

        // ✅ Signal that loading is complete after rendering the list.
        if (resolveHostedGames) {
            resolveHostedGames();
            resolveHostedGames = null; // Set to null so we only do this on the initial load.
        }
    });
}

function renderPlayedGames(snapshot) {
    playedGamesList.innerHTML = '';
    const titleElement = document.getElementById('played-games-title');

    if (!snapshot.exists()) {
        if (titleElement) titleElement.textContent = 'Played Games (0)';
        playedGamesList.innerHTML = '<p style="padding: 10px;">You have not played any games.</p>';
        if (resolvePlayedGames) {
            resolvePlayedGames();
            resolvePlayedGames = null;
        }
        return;
    }

    const gamesObject = snapshot.val();
    const games = [];
    for (const word in gamesObject) {
        games.push({ word: word, ...gamesObject[word] });
    }

    if (titleElement) titleElement.textContent = `Played Games (${games.length})`;

    if (games.length === 0) {
        playedGamesList.innerHTML = '<p style="padding: 10px;">You have not played any games.</p>';
        if (resolvePlayedGames) {
            resolvePlayedGames();
            resolvePlayedGames = null;
        }
        return;
    }
    
    // ✅ Get the current user's name to check against the host.
    const currentUsername = localStorage.getItem("gerNordleUsername");

    games.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));
    const metaPromises = games.map(game => database.ref(`games/${game.word}/metadata`).once('value'));

    Promise.all(metaPromises).then(metaSnapshots => {
        const fragment = document.createDocumentFragment();
        metaSnapshots.forEach((metaSnap, idx) => {
            if (metaSnap.exists()) {
                const meta = metaSnap.val();
                const gameData = games[idx];
                const gameLink = document.createElement('a');
                gameLink.href = generateShareURL(meta.word, meta.hint1, meta.hint2, meta.hint3, meta.funFact);
                
                const wordSpan = document.createElement('span');
                let wordText = (gameData.status === 'won' || gameData.status === 'lost') ? meta.word : '?????';

                // ✅ Check if the current user was the host of this game.
                if (meta.host && meta.host === currentUsername) {
                    wordText += ` <span style="color: #951414; font-weight: bold;">H</span>`;
                }
                wordSpan.innerHTML = wordText;

                const statusSpan = document.createElement('span');
                statusSpan.className = 'game-status';
                if (gameData.status === 'won') statusSpan.textContent = `Won (${gameData.guesses}/6)`;
                else if (gameData.status === 'lost') statusSpan.textContent = 'Lost';
                else statusSpan.textContent = 'In progress';
                
                gameLink.appendChild(wordSpan);
                gameLink.appendChild(statusSpan);
                fragment.appendChild(gameLink);
            }
        });
        playedGamesList.appendChild(fragment);

        if (resolvePlayedGames) {
            resolvePlayedGames();
            resolvePlayedGames = null;
        }
    });
}

// Replace your existing closeAccountSidebar function
function closeAccountSidebar() {
    accountSidebar.classList.remove('show');
    accountOverlay.hidden = true;
    mainContent.inert = false;

    // Detach the game list listeners
    if (hostedGamesRef) {
        hostedGamesRef.off('value', renderHostedGames);
    }
    if (playedGamesRef) {
        playedGamesRef.off('value', renderPlayedGames);
    }

    // ✅ NEW: Detach the stats listener when the sidebar is closed.
    if (statsRef && statsListener) {
        statsRef.off('value', statsListener);
    }

    // Reset all sidebar titles to their default state
    const sidebarTitle = document.getElementById('account-sidebar-title');
    const hostedTitle = document.getElementById('hosted-games-title');
    const playedTitle = document.getElementById('played-games-title');
    
    if (sidebarTitle) sidebarTitle.textContent = 'My Account';
    if (hostedTitle) hostedTitle.textContent = 'Hosted Games';
    if (playedTitle) playedTitle.textContent = 'Played Games';
}

let statsRef = null;
let statsListener = null;

async function openAccountSidebar() {
    const username = localStorage.getItem("gerNordleUsername");
    if (!username) {
        showToast("Please log in to view your account.", "error");
        return;
    }

    const sidebarTitle = document.getElementById('account-sidebar-title');
    if (sidebarTitle) sidebarTitle.textContent = username.toUpperCase();

    const sidebarLoader = document.getElementById('sidebar-loader');
    const sidebarContent = document.getElementById('sidebar-content');
    
    accountSidebar.classList.add('show');
    accountOverlay.hidden = false;
    mainContent.inert = true;
    sidebarLoader.style.display = 'block';
    sidebarContent.classList.remove('loaded');

    try {
        const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');

        const hostedGamesLoaded = new Promise(resolve => { resolveHostedGames = resolve; });
        const playedGamesLoaded = new Promise(resolve => { resolvePlayedGames = resolve; });

        // Attach live listeners for the game lists
        hostedGamesRef = database.ref(`userProfiles/${sanitizedUsername}/hostedGames`);
        hostedGamesRef.on('value', renderHostedGames);

        playedGamesRef = database.ref(`userProfiles/${sanitizedUsername}/playedGames`);
        playedGamesRef.on('value', renderPlayedGames);
        
        // ✅ NEW: Attach a real-time listener for the stats section.
        // This will update the stats initially and every time they change.
        statsRef = database.ref(`userProfiles/${sanitizedUsername}/stats`);
        statsListener = statsRef.on('value', renderAccountStats);
        
        await Promise.all([hostedGamesLoaded, playedGamesLoaded]);

        sidebarLoader.style.display = 'none';
        sidebarContent.classList.add('loaded');

    } catch (error) {
        sidebarLoader.style.display = 'none';
        sidebarContent.classList.add('loaded');
        console.error("Error loading account sidebar:", error);
    }
}

accountBtn.addEventListener('click', openAccountSidebar);
closeAccountBtn.addEventListener('click', closeAccountSidebar);
accountOverlay.addEventListener('click', closeAccountSidebar);

// This function starts listening for changes to the current user's record
function listenForUserDeletion(username) {
    stopUserDeletionListener(); // Stop any previous listeners first

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const userRef = database.ref('users/' + sanitizedUsername);

    const listener = userRef.on('value', (snapshot) => {
        // If snapshot.exists() is false, the user was deleted from the database
        if (!snapshot.exists()) {
            console.log("Current user was deleted from the database. Logging out.");
            
            // Stop the listener before we reload
            stopUserDeletionListener();

            // Clear local session and refresh the page
            localStorage.removeItem("gerNordleUsername");
            localStorage.removeItem("gerNordleUserPin");
            window.location.reload();
        }
    });

    // Store the reference and the listener so we can detach it later
    userListener = { ref: userRef, listener: listener };
}

// This function stops the listener to prevent memory leaks
function stopUserDeletionListener() {
    if (userListener.ref && userListener.listener) {
        userListener.ref.off('value', userListener.listener);
        userListener = { ref: null, listener: null };
    }
}

async function saveCompletedGameData(won) {
    const username = localStorage.getItem("gerNordleUsername");
    if (!username || !secret) return;

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    
    // Step 1: Prepare all the data that needs to be written.
    const creationDateToSave = new Date().toISOString();
    const hintStatusToSave = { hintUsed1, hintUsed2, hintUsed3, hintUsed4 };
    const guesses = won ? (currentRow + 1) : -1;

    // Data for the user's private profile in Firebase
    const finalPlayedGameData = {
        status: won ? 'won' : 'lost',
        guesses: guesses,
        createdDate: creationDateToSave,
        guessHistory: guessHistory,
        colorHistory: colorHistory,
        hintStatus: hintStatusToSave
    };
    
    // Data for the public game scoreboard
    const finalScoreData = {
        username: username,
        guesses: guesses,
        timestamp: new Date().toISOString(),
        hintCount: (hintUsed1 ? 1:0) + (hintUsed2 ? 1:0) + (hintUsed3 ? 1:0) + (hintUsed4 ? 1:0)
    };

    // Step 2: Create a single multi-path update object.
    const updates = {};
    updates[`/userProfiles/${sanitizedUsername}/playedGames/${secret}`] = finalPlayedGameData;
    updates[`/games/${secret}/${sanitizedUsername}`] = finalScoreData;
    updates[`/games/${secret}/players/${sanitizedUsername}`] = null;
    
    // Step 3: Perform the atomic write and then update stats.
    try {
        await database.ref().update(updates);
        // ONLY if the write succeeds, update the stats.
        await updateStats(username, won, guesses);

        // ✅ FIX: The local storage update is now correctly placed inside the 'try' block.
        const encodedSecret = base64Encode(secret);
        const allGameData = JSON.parse(localStorage.getItem("gerNordleGameData") || "{}");
        if (!allGameData[username]) allGameData[username] = {};
        
        // ✅ FIX: Corrected the object syntax and added the missing createdDate.
        const finalGameRecord = {
            status: won ? 'won' : 'lost',
            guessHistory: guessHistory, 
            colorHistory: colorHistory, 
            keyColors: keyColors,
            hintStatus: { 
                hintUsed1: hintUsed1, 
                hintUsed2: hintUsed2, 
                hintUsed3: hintUsed3, 
                hintUsed4: hintUsed4, 
                hintExpanded1: hintExpanded1, 
                hintExpanded2: hintExpanded2, 
                hintExpanded3: hintExpanded3, 
                hintExpanded4: hintExpanded4 
            },
            createdDate: creationDateToSave // This was missing
        };
        
        delete finalGameRecord.ongoingState;
        allGameData[username][encodedSecret] = finalGameRecord;
        localStorage.setItem("gerNordleGameData", JSON.stringify(allGameData));

    } catch (error) {
        console.error("Failed to save final game data:", error);
        throw error;
    }
}

async function deleteGame(wordToDelete) {
    if (!confirm(`Are you sure you want to permanently delete the game "${wordToDelete}"? This will remove it from every player's history and stats.`)) {
        return;
    }

    const hostUsername = localStorage.getItem("gerNordleUsername");
    if (!hostUsername) {
        alert("Could not verify user. Deletion failed.");
        return;
    }
    const sanitizedHostUsername = hostUsername.replace(/[.#$[\]]/g, '_');

    try {
        const gameSnapshot = await database.ref('games/' + wordToDelete).once('value');
        const gameData = gameSnapshot.val();

        const allPlayerNames = new Set();

        // --- FIX START ---
        // Unconditionally add the host to the list of players to be cleaned up.
        // This ensures the game is removed from the host's "playedGames" list
        // even if data is inconsistent.
        allPlayerNames.add(sanitizedHostUsername);

        // Now, find all OTHER players from the central game record.
        if (gameData) {
            Object.keys(gameData).forEach(key => {
                if (key !== 'metadata' && key !== 'players') {
                    allPlayerNames.add(key);
                }
            });
            if (gameData.players) {
                Object.keys(gameData.players).forEach(playerName => {
                    allPlayerNames.add(playerName);
                });
            }
        }
        // --- FIX END ---

        const updates = {};
        updates[`/games/${wordToDelete}`] = null;
        updates[`/userProfiles/${sanitizedHostUsername}/hostedGames/${wordToDelete}`] = null;

        allPlayerNames.forEach(sanitizedPlayerName => {
            updates[`/userProfiles/${sanitizedPlayerName}/playedGames/${wordToDelete}`] = null;
        });

        await database.ref().update(updates);

        // This check is needed because we might not have gameData if the record was already partially deleted.
        if (gameData) {
            const statPromises = [];
            allPlayerNames.forEach(sanitizedPlayerName => {
                const scoreData = gameData[sanitizedPlayerName];
                if (scoreData) {
                    const wasWin = scoreData.guesses > 0;
                    const guessesInGame = wasWin ? scoreData.guesses : 0;

                    const statRef = database.ref(`/userProfiles/${sanitizedPlayerName}/stats`);
                    const statPromise = statRef.transaction(currentStats => {
                        if (currentStats) {
                            currentStats.gamesPlayed = (currentStats.gamesPlayed || 0) - 1;
                            if (currentStats.gamesPlayed < 0) currentStats.gamesPlayed = 0;

                            if (wasWin) {
                                currentStats.wins = (currentStats.wins || 0) - 1;
                                if (currentStats.wins < 0) currentStats.wins = 0;

                                currentStats.totalGuesses = (currentStats.totalGuesses || 0) - guessesInGame;
                                if (currentStats.totalGuesses < 0) currentStats.totalGuesses = 0;
                            }
                        }
                        return currentStats;
                    });
                    statPromises.push(statPromise);
                }
            });

            if (statPromises.length > 0) {
                await Promise.all(statPromises);
            }
        }

        if (wordToDelete === secret) {
            window.location.reload();
        }

    } catch (error) {
        console.error("Comprehensive deletion failed:", error);
        alert("An error occurred while trying to delete the game. Please try again.");
    }
}

// This function handles closing the popup when the user starts typing a guess.
function handleTypingToClose(event) {
    // Check if the key pressed is a valid letter for the game.
    if (/^[a-zA-ZÄÖÜäöüßẞÆØÅæøå]$/.test(event.key)) {
        hideHintPopup();
    }
}

function loadCompletedGame(playedGameData) {
    const savedUsername = localStorage.getItem("gerNordleUsername");
    if (!savedUsername) return;

    const headerSetup = document.getElementById("header-setup");
    const gameElement = document.getElementById("game");

    // Use the new unified header logic
    setupUsernameInterface({
        isGamePage: true,
        containerId: 'setup-username-area',
        inputId: 'usernameInputGame',
        placeholder: 'Enter username'
    });

    initBoard();
    initKeyboard();

    const isSolved = playedGameData.status === 'won';
    document.getElementById("message").textContent = isSolved ? "You already solved this Wørtle! 🥳" : "You have already played this Wørtle.";

    const reconstructedKeyColors = {};
    if (playedGameData.guessHistory && playedGameData.colorHistory) {
        for (let i = 0; i < playedGameData.guessHistory.length; i++) {
            const guess = playedGameData.guessHistory[i];
            const colors = playedGameData.colorHistory[i];
            for (let j = 0; j < guess.length; j++) {
                const letter = guess[j];
                const color = colors[j];
                if (!reconstructedKeyColors[letter] || (color === 'correct') || (color === 'present' && reconstructedKeyColors[letter] === 'absent')) {
                    reconstructedKeyColors[letter] = color;
                }
            }
        }
    }
    keyColors = reconstructedKeyColors;
    updateKeyboardColors();
    updateHintButtons();

    const board = document.getElementById('board');
    board.innerHTML = generateGuessHistoryHTML(playedGameData.guessHistory, playedGameData.colorHistory);
    board.style.gridTemplateRows = 'none';

    showGameOverModal(isSolved, playedGameData.guessHistory, playedGameData.colorHistory, playedGameData.hintStatus);
    disableKeyboard(); 

    headerSetup.style.display = 'flex';
    gameElement.style.display = 'flex';
}

function loadOngoingGame(playedGameData) {
    const savedUsername = localStorage.getItem("gerNordleUsername");
    if (!savedUsername) return;

    const headerSetup = document.getElementById("header-setup");
    const gameElement = document.getElementById("game");

    // Use the new unified header logic
    setupUsernameInterface({
        isGamePage: true,
        containerId: 'setup-username-area',
        inputId: 'usernameInputGame',
        placeholder: 'Enter username'
    });

    initBoard();
    initKeyboard();

    // Restore all game variables from the passed-in Firebase data.
    usernameSet = true;
    grid = playedGameData.grid;
    currentRow = playedGameData.currentRow;
    guessHistory = playedGameData.guessHistory || [];
    colorHistory = playedGameData.colorHistory || [];
    keyColors = playedGameData.keyColors || {};
    
    const hintStatus = playedGameData.hintStatus || {};
    hintUsed1 = hintStatus.hintUsed1;
    hintUsed2 = hintStatus.hintUsed2;
    hintUsed3 = hintStatus.hintUsed3;
    hintUsed4 = hintStatus.hintUsed4;
    hintExpanded1 = hintStatus.hintExpanded1 || false;
    hintExpanded2 = hintStatus.hintExpanded2 || false;
    hintExpanded3 = hintStatus.hintExpanded3 || false;
    hintExpanded4 = hintStatus.hintExpanded4 || false;
    currentCol = 0;
    
    // Apply the restored state to the UI.
    updateBoard();
    if (Array.isArray(colorHistory)) {
        for (let r = 0; r < colorHistory.length; r++) {
            const colors = colorHistory[r];
            const rowDiv = document.getElementById("board").children[r];
            if (Array.isArray(colors) && rowDiv) {
                for (let c = 0; c < cols; c++) {
                    if (rowDiv.children[c] && typeof colors[c] === 'string') {
                        rowDiv.children[c].classList.add(colors[c]);
                    }
                }
            }
        }
    }
    updateKeyboardColors();
    updateHintButtons();
    
    gameElement.classList.remove("dimmed");
    headerSetup.style.display = 'flex';
    gameElement.style.display = 'flex';
}

function renderAccountStats(snapshot) {
    const statsSection = document.getElementById('account-stats-section');
    if (!statsSection) return;

    const stats = snapshot.val() || { gamesPlayed: 0, wins: 0, totalGuesses: 0 };
    const winPct = stats.gamesPlayed > 0 ? ((stats.wins / stats.gamesPlayed) * 100).toFixed(1) : "0.0";
    
    statsSection.innerHTML = `
        <div class="stat-item">
            <span class="stat-value">${stats.gamesPlayed}</span>
            <span class="stat-label">Played</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${stats.wins}</span>
            <span class="stat-label">Wins</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${winPct}%</span>
            <span class="stat-label">Win %</span>
        </div>
    `;
}

function showToast(message, type = '') {
    const container = document.getElementById('toast-container');
    if (!container) return;

    // Create the toast element
    const toastElement = document.createElement('div');
    toastElement.className = 'toast';
    if (type) {
        toastElement.classList.add(type);
    }
    toastElement.textContent = message;

    // Add it to the container
    container.appendChild(toastElement);

    // Set a timer to remove the toast after its animation finishes
    setTimeout(() => {
        toastElement.remove();
    }, 3000); // 3000ms = 3 seconds
}

async function displayHostCredit() {
    const creditElement = document.getElementById('host-credit');
    if (!secret || !creditElement) return;

    try {
        const hostRef = database.ref(`games/${secret}/metadata/host`);
        const snapshot = await hostRef.once('value');

        if (snapshot.exists()) {
            const hostName = snapshot.val();
            creditElement.textContent = `Wørtle by: ${hostName}`;
        }
    } catch (error) {
        console.error("Could not fetch host name for credit:", error);
    }
}

</script>
</body>
</html>
